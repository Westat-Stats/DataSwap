*this version used different recode scheme for proc corr and proc reg *;
***********************************************************************;
*                                                                     *;
*         NAME:       DataSwap SAS Marco                              *;
*         PROGRAM:    DATASWAP.MAC                                    *;
*         VERSION:    Version 3.3.2                                   *;
*         INIT DATE:  10/08/04                                        *;
*         MODF DATE:  12/30/17                                        *;
*         PURPOSE:    Select swaps and their partners.                *;
*         Developed under contract with NCES/IES/DOE                  *;
*                                                                     *;
*                     SEE DOCUMENTS FOR DETAILS.                      *;
*                                                                     *;
*         The program was originated from Steve Kaufman's 4 macro set:*;
*         1. rswapfnl2.mac                                            *;
*         2. cerdet.mac                                               *;
*         3. SYSSEL1W.mac                                             *;
*         4. swapfnl.mac                                              *;
*                                                                     *;
*         SIGNIFICANT CHANGES WITH THIS VERSION:                      *;
*                                                                     *;
*         1) Fix label/increment problem in summary for nMod > 4 - WH *;
*         2)                                                          *;
*         3)                                                          *;
*         4)                                                          *;
*         5)                                                          *;
*                                                                     *;
***********************************************************************;

%macro DataSwap(
   rate=,
   seed=0,
   id=,
   mos=1,
   boundary=,
   boundary_t=,
   sortvars=,
   stratum=1,
   swapvars=,
   swapvars_t=,
   linkswap=,
   missingvar=,
   r_method=,
   biasvar=,
   wgt=,
   varstrat=,
   varunit=,
   data=,
   out=,
   keyout=,
   keyvars=,
   keyvars_t=,
   models=,
   modelclass=,
   tolflag=0.1,
   maxcat=,
   listpair=,
   impute=y,
   missingdef=,
   SWAPVARS_MD=,
   BOUNDARY_MD=,
   KEYOUT_MD=,
   KEYVARS_MD=,
   SWAPMETH=,
   corrpred=,
   sequence=,
   debug=0,
   tempfile=,
   showobs=,
   NL=,
   graphtype=rtf,
   usedpi=
   );

   %local slash;
   %if &sysscp=WIN %then %let slash=%str(\);
   %else %if &sysscp=LINUX %then %let slash=%str(/);

   /*** parse seed to determine if this is a summary run ***/
   %local pos dropdsn nRun iRun program_name program_prefix program_suffix program_path;

   %let nRun=1;
   %let seed=%sysfunc(compbl(&seed));
   %let nRun=%eval(%sysfunc(countc(&seed," "))+1);

   %do iRun=1 %to &nRun;
      %local seed&iRun;
      %let seed&iRun=%scan(&seed,&iRun,%str( ));
   %end;
   %let program_name=%sysfunc(getoption(sysin));

   %let program_prefix=%scan(&program_name,-1,&slash.);
   /*%let pos=%index(%upcase(&program_prefix),%str(_SUMMARY.SAS));*/
   %let pos=%index(%upcase(&program_prefix),%str(.SAS));
   %if &pos>0 %then %do;
      %let program_prefix=%substr(&program_prefix,1,%eval(&pos-1));
   %end;

   %let program_path=%substr(&program_name,1,%eval(%length(&program_name)-%length(&program_prefix)-4));


   /*define global variables in the root program */

   %if &nRun ne 1 or %length(&sequence)=0 %then %do;
      %local ErrRun prgname nerr MyGlobal;
   %end;


   %if &nRun ne 1 %then %do;

      %do i=1 %to &nRun;

         filename __fl "&program_path.&program_prefix._Run&i..sas";

         data _null_;
            file __fl n=ps;
            put //
            "********** Run &i **********;"///
            "%" "DataSwap(" /
            "         rate=&rate,"/
            "         seed=&&seed&i,"/
            "         id=&id,"/
            "         mos=&mos,"/
            "         boundary=&boundary,"/
            "         boundary_t=&boundary_t,"/
            "         sortvars=&sortvars,"/
            "         stratum=&stratum,"/
            "         swapvars=&swapvars,"/
            "         swapvars_t=&swapvars_t,"/
            "         linkswap=&linkswap,"/
            "         missingvar=&missingvar,"/
            "         r_method=&r_method,"/
            "         biasvar=&biasvar,"/
            "         wgt=&wgt,"/
            "         varstrat=&varstrat,"/
            "         varunit=&varunit,"/
            "         data=&data,"/
            "         out=&out._Run&i,"/
            "         keyout=&keyout,"/
            "         keyvars=&keyvars,"/
            "         keyvars_t=&keyvars_t,"/
            "         models=&models,"/
            "         modelclass=&modelclass,"/
            "         tolflag=&tolflag,"/
            "         maxcat=&maxcat,"/
            "         listpair=&listpair,"/
            "         impute=&impute,"/
            "         missingdef=&missingdef,"/
            "         SWAPMETH=&swapmeth,"/
            "         BOUNDARY_MD=&boundary_md,"/
            "         SWAPVARS_MD=&swapvars_md,"/
            "         KEYVARS_MD=&keyvars_md,"/
            "         KEYOUT_MD=&keyout_md,"/
            "         corrpred=&corrpred,"/
            "         sequence=&i,"/
            "         debug=&debug,"/
            "         tempfile=&tempfile,"/
            "         showobs=&showobs,"/
            "         NL=&NL,"/
            "         graphtype=&graphtype,"/
            "         usedpi=&usedpi"/
            ")";
         run;

         options pageno=1;
         proc printto log="&program_path.&program_prefix._Run&i..LOG" new; run;
         proc printto print="&program_path.&program_prefix._Run&i..LST" new; run;
         %include "&program_path.&program_prefix._Run&i..sas";
         proc printto log=log; run;
         proc printto print=print; run;

         %if %sysfunc(fileexist(&program_path.&program_prefix._Run&i..sas)) %then %do;
            %let rc = %sysfunc(fdelete(__fl));
         %end;

         filename __fl clear;
      %end;
      %goto endpoint;
   %end;

   %if %length(&sequence) ne 0 %then %do;
      %let program_suffix=Run;
   %end;
   %else %do;
      %let program_suffix=Test;
   %end;

%local vernum nobs myGlobal;
%local err1 err2 err3 err4 err5 niter;
%local tmpdsn alloc holder tmpcelldef tmpcell lval ls notes;
%local i j invars prnvars outvars;
%local n_var n_boundvar n_cellvar n_swapvars n_keyouts n_keyvars;
%local n_models n_modelclass;
%local nzone zone b_var cumdata ;
%local celln selwgt sampflag swapcell certflag;
%local noswap swp_RENAME swp_IF swp_DROP;
%local rateisnum ActualSeed;
%local tolflag1 tolflag2 tolflag3 tolflag4 listpair1 listpair2;
%local linkvars n_linkvars n_linksets n_imputed useRandom;
%local swapsap dropvars1 dropvars2 last_boundary;
%local nchop nlimit;

%let reports=y;
%let certflag=;
%let niter=0;
%let nerr=0;
%let prgname=DataSwap;
%let vernum=Version 3.3.2;
%let celln=__celln;
%let selwgt=__selwgt;
%let sampflag=__sampflag;

%let tmpdsn = __indat;
%let alloc =  __alloc;
%let tmpcell = __tmpcell;
%let holder = __holder;
%let swapsap=__swapsap;

%let outvars=&celln &selwgt &sampflag;

%let notes = %SYSFUNC(GETOPTION(NOTES));
%let ls = %SYSFUNC(GETOPTION(LINESIZE));

/***options nonotes;***/

%****assume 20 variables in SWAPCELL, SWAPVARS;

%let nlimit=20;
%do i = 1 %to &nlimit;
   %local cell&i.;
   %local scell&i;
   %local swapvar&i.;
   %local vts&i;
   %local vtb&i;
   %local nmiss&i.;     /*number of missing obs*/
   %local missset&i;
   %local linkvar&i;
   %local n_link&i.;
   %local linkset&i.;
   %let n_link&i=0;
   %let nmiss&i=0;
   %local err&i;
   %do j=1 %to 200;
      %local linkv&i&j;
   %end;
%end;

%****assume 200 variables in LINKSWAP;
%do i = 21 %to 200;
   %local cell&i.;
   %local linkvar&i;
%end;

****set obs on/off for debugging purpose;
%if %upcase(%trim(&showobs)) ne Y %then %do;
   %let showobs=NOOBS;
%end;
%else %do;
   %let showobs=;
%end;

****check if parameters are valid****;

%ds_validate()

%if %length(&err1) > 1 %then %do;
   %ds_prnerror;
   %goto endpoint;
%end;

****prepare chops to hold strings****;

data _null_;
   __max=max(length("&swapcell"),length("&linkvars"),length("&keyvars"),length("&keyout"));
   call symput("nchop",left(put(ceil(__max/(&LS-52))+1,8.)));
run;

%do i=1 %to &nchop;
   %local chop&i;
%end;

**** impute missing swapvars****;
%local saveSwapvars saveB_var saveSwapcell;
%let saveSwapcell=&swapcell;
%let saveSwapvars=&swapvars;
%let saveB_var=&b_var;
%let cumdata=&data;

%ds_impute()

%if %length(&err1) > 1 %then %do;
   %ds_prnerror
   %goto endpoint;
%end;

**** check value if swapmeth=2****;

%ds_swapmeth2()

%if %length(&err1) > 1 %then %do;
   %ds_prnerror;
   %goto endpoint;
%end;

**** set up stratum, mos, wgt if none specified ****;

data &tmpdsn;
   set &cumdata;

   __one=1;

   %if %length(&stratum) = 0 %then %do;
      %let dropvars2=&dropvars2 __stratum;
      %let stratum=__stratum;
      &stratum = 1;
   %end;
   %else %if %str(&stratum) = 1 or %str(&stratum) = 1.0 %then %do;
      %let dropvars2=&dropvars2 __stratum;
      %let stratum=__stratum;
      &stratum = 1;
   %end;

   %if %length(&mos) = 0 %then %do;
      %let dropvars1=&dropvars1 __mos;
      %let mos=__mos;
      &mos=1;
   %end;
   %else %if %str(&mos) = 1 or %str(&mos) = 1.0 %then %do;
      %let dropvars1=&dropvars1 __mos;
      %let mos=__mos;
      &mos=1;
   %end;

   %if %length(&wgt) = 0 %then %do;
      %let dropvars2=&dropvars2 __wgt;
      %let wgt=__wgt;
      &wgt=1;
   %end;
   %else %if %str(&wgt) = 1 or %str(&wgt) = 1.0 %then %do;
      %let dropvars2=&dropvars2 __wgt;
      %let wgt=__wgt;
      &wgt=1;
   %end;

   &tmpcell=compress(&tmpcelldef);
run;

/*
**** summarize counts after separating records with missing values****;
%let calc_rate=&rate;
%put calc_rate=&calc_rate;
%if %length(&miss_statement)>0 %then %do;
   %let drop_miss = __mrate ;
   %ds_adjmiss;
%end;

%if %length(&err1) > 1 %then %do;
   %ds_prnerror;
   %goto endpoint;
%end;
*/

****check if variables used numerically are indeed of numeric type****;
%ds_varvalid

%if %length(&err1) > 1 %then %do;
   %ds_prnerror;
   %goto endpoint;
%end;

****check if a variable has missing value****;
%ds_chkmiss(type=id,VAR=&id);
%ds_chkmiss(type=rate,VAR=&rate);
%ds_chkmiss(type=mos,VAR=&mos);
%ds_chkmiss(type=stratum,VAR=&stratum);
%ds_chkmiss(type=biasvar,VAR=&b_var);
%ds_chkmiss(type=wgt,VAR=&wgt);

%if %length(&err1) > 1 %then %do;
   %ds_prnerror;
   %goto endpoint;
%end;

****check if a variable is within range****;
%ds_chkrange(type=rate,VAR=&rate)
%ds_chkrange(type=mos,VAR=&mos)

%if %length(&err1) > 1 %then %do;
   %ds_prnerror;
   %goto endpoint;
%end;

*;
* define zone if boundary is specified;
*;

%if %length(&boundary) > 0 %then %do;

%let zone=__zone;
%put %str(                    )****define zone if boundary is specified****;

proc sort data=&tmpdsn;
   by &boundary &swapvars;
run;

proc sort data=&tmpdsn nodupkey out=__tmp1(keep=&boundary);
   by &boundary;
run;

data __tmp1;
   if eof then call symput("nzone",left(put(_n_-1,8.0)));
   retain &zone 0;
   set __tmp1 end=eof;
   &zone+1;
run;

data &tmpdsn;
   merge &tmpdsn __tmp1;
   by &boundary;
run;

%if &debug=y %then %do;
proc print data=&tmpdsn;
   title3 "debug : &tmpdsn after assign zone";
run;
%end;

%end;

*;
* assign sequential cell numbers and calculate number of levels;
*;

proc sort data=&tmpdsn;
   by &tmpcell;
run;

data &tmpdsn;
   if eof then call symput('lval',left(put(&celln,8.)));
   retain &celln 0;
   set &tmpdsn end=eof;
   by &tmpcell;
   if first.&tmpcell then &celln+1;
   drop &tmpcell;
run;

%if &debug=y %then %do;
proc print data=&tmpdsn;
   var &id __zone &boundary &swapvars &celln;
   title3 "debug : &tmpdsn after assign &celln";
run;
%end;


%if %length(&certflag) > 0 %then %do;
*;
* separate certainties if any pre-defined;
*;
   data __cert &tmpdsn;
      set &tmpdsn;
      if &certflag=1 then output __cert;
      else output &tmpdsn;
   run;

   data __cert;
      set __cert;
      __select1='1';
      &sampflag='c';
      &selwgt.1=1;
   run;
%end;

*;
* generate allocation file;
*;

proc summary nway data=&tmpdsn;
   class &stratum. %if &rateisnum=0 %then &rate. ; ;  ***** new;
   var __one &mos ;
   output out=__total(drop=_type_ _freq_) sum=__totaln __totalm;
   ****id &stratum.;
run;

%if &debug=y %then %do;
proc print data=__total;
   title3 "debug : __total";
run;
%end;

data &alloc;
   set __total;
   __n=round(&rate*__totaln,1);
   keep &stratum __n;
   *****strata=1;
   /*put __n= __totaln= %if &rateisnum=0 %then &rate= ; ;*/
run;

%if &debug=y %then %do;
proc print data=&alloc;
   title3 "debug : &alloc";
run;
%end;

*;
* determine certainty units;
*;

%Certainties(
   frame=&tmpdsn,
   allocfil=&alloc,
   meas=&mos,
   pmeas=__pmos,
   stratum=&stratum,
   stratumr=&stratum.r,
   nwallocf=__newalloc,
   samppart=nation,
   certind=&sampflag);

%if &debug=y %then %do;
proc print data=&alloc;
   title3 "debug : &alloc after certdet";
run;

proc print data=&tmpdsn;
   title3 "debug : &tmpdsn after certdet";
run;

proc print data=__newalloc;
   title3 "debug : newalloc after certdet";
run;
%end;

*;
* sort the file by &swapcell;
*;

/* wch : original
proc sort data=&tmpdsn;
by &cell;
*/

%if %length(&sortvars)>0 %then %do;
   **** sort data by &stratumr &sortvars, if sortvars is sepcified ****;
   proc sort data=&tmpdsn;
      by &stratum.r &sortvars;
   run;
%end;
%else %do;
   proc sort data=&tmpdsn;
      by &stratum.r __celln;
   run;
%end;

%if &debug=y %then %do;
proc print data=&tmpdsn;
   title3 "debug : &tmpdsn before sel3pstr";
run;
%end;

*;
* select cases to be swapped;
*;

%NonCertainties(
   data=&tmpdsn,
   stratumr=&stratum.r,
   namsel=__select1,
   size=__pmos,
   seed=&actualseed,
   samsz=__newalloc,
   certind=&sampflag,
   sortvars=&sortvars,
   schwtprf=&selwgt,
   botn=1);

%if &debug=y %then %do;
proc print data=&tmpdsn;
   title3 "debug : &tmpdsn after sel3pstr";
run;
%end;

/***
data inf.aftersel3;
   set &tmpdsn;
run;
***/

**** put the pre-defined certainties back ****;
%if %length(&certflag) > 0 %then %do;
    data &tmpdsn;
       set &tmpdsn __cert;
    run;
%end;

data __swap;
   set &tmpdsn;
   if __select1 gt '0';
   drop __pmos &selwgt.1 __select1
   &dropvars1 &stratum.r &sampflag;
run;

/*abort if no case selected*/
/*new feature ESSIN 2015*/
/*
data __swap;
   set __swap;
   if __celln=.;
run;
*/
%local nselected;
%let nselected=0;
proc sql noprint;
   select nobs into :nselected
   from dictionary.tables
   where libname='WORK' and memname='__SWAP';
quit;
%put nselected=&nselected;
%if &nselected=0 %then %do;
   %let err1=&prgname Error: There were no cases selected during the sampling process.;
   %let err2=&prgname Error: Consider making a change to the strata or rate parameter.;
   %let nerr=2;
   %ds_prnerror;
   %goto endpoint;
%end;

data &tmpdsn
     &holder;
   set &tmpdsn;
   drop __select1
   &dropvars1 &stratum.r __pmos &selwgt.1;
run;

*;
* Do the swapping;
*;


%if &SWAPMETH=1 or &n_swapvars=1 %then %do;
   %let useRandom=0;

   /***
   %put swapcell=&swapcell;
   %put celln=&celln;
   %put swapvars=&swapvars;
   ***/

   %Swap(
      data=&tmpdsn,
      sdata=__swap,
      swaps=__sswaps,
      lval=&lval,
      seed=&actualseed,
      boundary=&boundary,
      cell=&swapcell,
      celln=&celln,
      id=&id,
      swapvar=&swapvars,
      biasvar=&b_var,
      wgt=&wgt
      );
%end;
%else %do;

   data _null_;
      __x = &nobs/&n_swapvars;
      if int(__x) ne __x then
         call symput("useRandom",left(put(int(__x)+1,8.0)));
      else
         call symput("useRandom",left(put(int(__x)  ,8.0)));

   run;
   /***%let useRandom=%eval(&nobs / &n_swapvars);***/

/***%put useRandom=&useRandom;***/

   data &tmpdsn;
      set &tmpdsn;
      __rannum = ranuni(&actualseed);
   run;
   proc sort data=&tmpdsn;
      by __rannum;
   run;
   data &tmpdsn;
      set &tmpdsn;
      if 0 < _n_ <= %eval(&useRandom) then __group=1;
      %do i = 2 %to &n_swapvars;
      else if %eval(%eval(&i-1)*&useRandom) < _n_ <= %eval(&i*&useRandom) then __group=&i;
      %end;
      drop __rannum ;
   run;

   %if %length(&boundary) > 0 %then %do;

      %put ****re-define zone if boundary is specified****;

      proc sort data=&tmpdsn (drop=__zone);
         by __group &boundary &swapvars;
      run;

      proc sort data=&tmpdsn nodupkey out=__tmp1(keep=__group &boundary);
         by __group &boundary;
      run;

      data __tmp1;
         if eof then call symput("nzone",left(put(_n_-1,8.0)));
         retain &zone 0;
         set __tmp1 end=eof;
         &zone+1;
      run;

      data &tmpdsn;
         merge &tmpdsn __tmp1;
         by __group &boundary;
      run;

   %end;

   /***
   proc freq data=&tmpdsn;
      title3 "debugging before swap";
      tables __group*__sampflag/missing;
   run;
   ***/

   %local k names;

   %do i = 1 %to &n_swapvars;

      %**** construct swapvars for this group ****;
      %local lval&i tmpcelldef&i tmpcell&i tmpdsn&i celln&i;
      %local swapvars&i swapcell&i b_var&i nswap&i namelen;
      %let tmpdsn&i=__tmpdata&i;
      %let tmpcell&i=__tmpcell&i;
      %let celln&i=__celln&i;

      %let k=0;
      %let names=;
      %let namelen=0;

      %do j = 1 %to &n_swapvars;
         %if &j ne &i %then %do;
            %let k=%eval(&k+1);
            %let cell&k=&&swapvar&j;
            %let names=&names __names&k "&&swapvar&j";
            %if %length(&&swapvar&j) > &namelen %then
               %let namelen=%length(&&swapvar&j);
         %end;
      %end;

      data __tmp1;
         do __group = 1 to &k;
            __rannum=ranuni(&actualseed);
            output;
         end;
      run;

      proc sort data=__tmp1;
         by __rannum;
      run;

      data _null_;
         array __names(&k) $ &namelen. __names1-__names&k ;
         retain __names1-__names&k &names;
         array __g(&k) __group1-__group&k;
         retain __group1-__group&k;
         if eof then do;
            %do j = 1 %to &k;
               call symput("cell&j",left(__names(__g(&j))));
            %end;
         end;
         set __tmp1 end=eof;

         __g(_n_)=__group;
      run;

      %let swapcell&i=__group &boundary;
      %let tmpcelldef&i=__group||;
      %do j=1 %to &n_boundvar;
          %LET tmpcelldef&i=&&tmpcelldef&i%SCAN(&boundary,&j,%str( ))||;
      %end;
      %do j=1 %to &k;
         %let swapvars&i = &&swapvars&i &&cell&j;
         %let tmpcelldef&i=&&tmpcelldef&i..&&cell&j.||;
         %if %index(%quote(%str( )%upcase(&&swapcell&i)%str( )),%quote(%str( )%upcase(&&cell&j)%str( )))=0 %then
            %let swapcell&i=&&swapcell&i &&cell&j;
      %end;
      %let b_var&i=&&swapvar&i;
      %let swapvars&i=&&swapvars&i &&swapvar&i;
      %let tmpcelldef&i=&&tmpcelldef&i..&&swapvar&i;
      %if %index(%quote(%str( )%upcase(&&swapcell&i)%str( )),%quote(%str( )%upcase(&&swapvar&i)%str( )))=0 %then
         %let swapcell&i=&&swapcell&i &&swapvar&i;
/*
%put swapcell&i=&&swapcell&i;
%put swapvars&i=&&swapvars&i;
%put tmpcelldef&i=&&tmpcelldef&i;
%put b_var&i=&&b_var&i;
*/
      data &&tmpdsn&i;
         set &tmpdsn;
         if __group=&i;
         &&tmpcell&i=compress(&&tmpcelldef&i);
      run;

      proc sort data=&&tmpdsn&i;
         by &&tmpcell&i;
      run;

      data &&tmpdsn&i;
         if eof then call symput("lval&i",left(put(&&celln&i,8.)));
         retain &&celln&i 0;
         set &&tmpdsn&i end=eof;
         by &&tmpcell&i;
         if first.&&tmpcell&i then &&celln&i+1;
         drop &&tmpcell&i;
      run;

      data __swap&i;
         set &&tmpdsn&i;
         /**/
         /* was if __sampflag ='n' fixed 7/31/06 */
         /**/
         if __sampflag in ('c','n');
         if __group=&i;
         drop &sampflag;
      run;

      %let nswap&i = %ds_nobs(dataset=__swap&i) ;
      %if &&nswap&i=0 %then %do;
         %put Group &i has no selected cases.  No swap needed.;
         %goto next_var;
      %end;

%if &debug=y %then %do;
proc print data=&&tmpdsn&i;
   title "i=&i";
var &id __zone __group &boundary &&celln&i &&swapvars&i;
run;
%end;

      %Swap(
         data=&&tmpdsn&i,
         sdata=__swap&i,
         swaps=__sswaps&i,
         lval=&&lval&i,
         seed=&actualseed,
         boundary=__group &boundary,
         cell=&&swapcell&i,
         celln=&&celln&i,
         id=&id,
         swapvar=&&swapvars&i,
         biasvar=&&b_var&i,
         wgt=&wgt
         );

      /***
      proc append data=__swap&i base=__swap;
      run;
      proc contents data=&&tmpdsn&i;
         title "&&tmpdsn&i";
      run;
      ***/

%next_var:

   %end;

   proc datasets nolist;
      delete &tmpdsn ;
   quit;

   %do i = 1 %to &n_swapvars;
      proc append data=&&tmpdsn&i(drop=&&celln&i) base=&tmpdsn;
      run;
      %if &&nswap&i ne 0 %then %do;
         proc append data=__sswaps&i base=__sswaps;
         run;
      %end;
   %end;
   proc datasets nolist;
      delete  __tmpdata1-__tmpdata&n_swapvars __swap1-__swap&n_swapvars
      %do i = 1 %to &n_swapvars;
         %if &&nswap&i ne 0 %then __sswaps&i ;
      %end;
      ;
   quit;

   proc sort data=&tmpdsn;
      by &id;
   run;
%end;

%if %length(&err1) > 0 %then %goto endpoint;

data &out;
   set &tmpdsn(drop=__one &zone &celln);
   by &id;

   drop &sampflag &dropvars2
   %do i=1 %to &n_swapvars;
      %if &&nmiss&i ne 0 %then &&swapvar&i;
   %end;
   %if &swapmeth=2 and &n_swapvars > 1 %then __group;
   ;
run;

proc sort data=__sswaps out=&swapsap;
   by __s&id;
run;

/***
data &swapsap;
   set __sswaps;
run;
***/

%ds_info;

%if %upcase(%trim(&reports))=Y %then %do;
   %ds_reports;
%end;

/** if summary is specified */
/** keep datasets for summary */

%if %length(&sequence) ne 0 %then %do;
proc sql noprint;
   create table __HD&sequence as select * from __HD;
  %if %eval(&n_swapvars + &n_keyvars) > 1 %then
   create table __ASED2_&sequence as select * from __ASED2; ;
  %if &n_keyouts>0 or &n_models>0 %then
   create table __ASED3_&sequence as select * from __ASED3; ;
quit;
%end;

options nonotes;
proc datasets nolist;
   delete &alloc __cand __cells __cont __error __extreme __extremes
          %if &niter>1 %then __final __id __s&id ;
          __frame __frmn __holder __input &tmpdsn __newalloc
          __nnum __prealloc __repeat __sswaps __swap __swapdata
          __swp __swpchk __total __totalst __transn &swapsap.
          __tst __tst1 %if %length(&certflag) > 0 %then __cert;
          ;
   delete __af __be __HD __combined __oneHD
        %if %eval(&n_swapvars + &n_keyvars) > 1 %then
          __ASED2 __oneCHISQ;
        %if &n_keyouts>0 or &n_models>0 %then
          __ASED3 ;
        %if &n_keyouts>0 %then
          __ased_reg_default
        %if &n_models>0 %then
          __ased_reg_user;
          %if %length(&varstrat)>0 and %length(&varunit)>0 %then
          __responsetable;
          %if %length(&varstrat)>0 and %length(&varunit)>0 and &n_keyouts>0 %then
          __domaintable;
          __ased_corr;
quit;
options &notes;

/*** did not save significant CPU
proc sql noprint nofeedback;
   drop table
          &alloc, __cand, __cells, __cont, __error, __extreme, __extremes,
          %if &niter>1 %then __final, __id, __s&id, ;
          __frame, __frmn, __holder, __input, &tmpdsn, __newalloc,
          __nnum, __prealloc, __repeat, __sswaps, __swap, __swapdata,
          __swp, __swpchk, __total, __totalst, __transn, &swapsap.,
          __tst, __tst1, %if %length(&certflag) > 0 %then __cert,;
          __af, __be, __HD, __combined, __oneHD, __oneCHISQ,
          __ased, __ased_corr, __ased_reg_default, __ased_reg_user
          ;
quit;
***/

%endpoint:

%if &nRun ne 1 and &nerr=0 %then %do;
   %summary
%end;

%if &nRun ne 1 and %length(&ErrRun)>0 %then %do;
   %put ;
   %put ;
   %put *********************************************************************************;
   %put NOTE***: MACRO %UPCASE(&prgname) ENDED BECAUSE OF ERROR(S) in Run &ErrRun..;
   %put NOTE***: Please refer to &program_path.&program_prefix._Run&ErrRun..LOG for details.;
   %put *********************************************************************************;
   %put ;
   %put ;
%end;
%if &nerr ne 0 or &syscc>4 %then %do;
   %put ;
   %put ;
   %put **************************************************;
   %put NOTE***: MACRO %UPCASE(&prgname) ENDED BECAUSE OF ERROR(S).;
   %put **************************************************;
   %put ;
   %put ;
   %if %length(&ErrRun)=0 %then %let ErrRun=&sequence;
%end;
%else %do;
   %put ;
   %put ;
   %put *****************************************;
   %put NOTE***: MACRO %UPCASE(&prgname) ENDING EXECUTION.;
   %put *****************************************;
   %put ;
   %put ;
%end;

title3;
footnote;
/***%put myGlobal=&myGlobal;***/
%symdel &myGlobal;


   /*
   %put *Show any datasets created here needs to be purged*;
   proc datasets;
   quit;
   */

/***option &notes;***/
%mend DataSwap;

*****subrouinte imputing missing swapars*****;
%macro ds_impute(string=);
   %local i j missvals n_missvals n_misssets;

   %let n_imputed=0;
   %if %upcase(%substr(&impute,1,1)) ne Y %then %goto exit_impute;

   %****set formats of SWAPVARS****;

   %do i = 1 %to &n_swapvars;
      %local fm&i hasmiss&i;
       data _null_;
          if _n_ = 1 then set &data (keep=&&swapvar&i);
          vt = vtype(&&swapvar&i);
          call symput("vt&i", vt);
          stop;
       run;
   %end;

   %****IF IMPUTE=Y and MISSINGDEF=blank****;

   %if %length(&missingdef) = 0 %then %do;
      %do i=1 %to &n_swapvars;
         %let hasmiss&i=0;

/***%put debug swapvar&i=&&swapvar&i vt&i=&&vt&i;***/

         /***%if &&vt&i=C %then %do;***/
            proc freq data=&data;
               where missing(&&swapvar&i);
               tables &&swapvar&i/noprint missing out=__tmp1(keep=&&swapvar&i);
            run;

            %let hasmiss&i=%ds_nobs(dataset=__tmp1);

            /***
            data _null_;
               set __tmp1;
               if &&swapvar=' ' then call symput("hasmiss&i","1");
            run;
            ***/

            %if &&hasmiss&i ne 0 %then %do;
               %if &&vt&i=C %then
                  %let missingdef=&missingdef#' ';
               %else %do;
                  %let mstring=;
                  %ds_missing(dataset=__tmp1,n=&&hasmiss&i,var=&&swapvar&i,vtype=&&vt&i);
                  %let missingdef=&missingdef#&mstring;
               %end;
            %end;
            %else /***%if %length(&missingdef)>0 %then ***/
               %let missingdef=&missingdef#null;
         /***%end;
         %else %do;
            proc means data=&data noprint;
               var &&swapvar&i;
               output out=__tmp1(keep=__nmiss) nmiss=__nmiss;
            run;
            data _null_;
               set __tmp1;
               if __nmiss > 0 then call symput("hasmiss&i","1");
            run;
            %if &&hasmiss&i ne 0 %then
               %let missingdef=&missingdef#.;
            %else %if %length(&missingdef)>0 %then
               %let missingdef=&missingdef#null;
         %end;   ***/
/*%put variable &&swapvar&i has &&hasmiss&i level of missing values.;*/
      %end;

      %****there is no missing, no default needed****;
      %if %length(&missingdef)=0 %then %goto exit_impute;

      %let missingdef=%substr(&missingdef,2);
/*%put default missingdef=&missingdef;*/
   %end;

   %****parse MISSINGDEF****;

   %let n_missvals=0;
   %let n_misssets=0;

   %if %index(&missingdef,#)=1 %then
      %ds_words(string=null&missingdef,delim=%str(#));
   %else
      %ds_words(string=&missingdef,delim=%str(#)) ;

   %let n_misssets=&n_var;

   %if &n_misssets ne 0 and &n_swapvars ne &n_misssets %then %do;
      %let err1=&prgname Error: The number of variables in SWAPVARS does not match the number of sets in MISSINGDEF.;
      %let err2=&prgname Error: There are &n_swapvars variables in SWAPVARS but &n_misssets set of missing values in MISSINGDEF.;
      %let err3=&prgname Error: You have specified SWAPVARS=&swapvars and MISSINGDEF=&missingdef..;
      %let nerr=3;
   %end;

   %if %length(&err1) > 1 %then %goto exit_impute;

%if &debug=1 %then %do;
%put missingdef=&missingdef;
%put n_misssets=&n_misssets;
%put;
%end;

   %do i=1 %to &n_misssets;
       %local missclause&i n_miss&i ;

       %let missset&i=%trim(%unquote(&&cell&i));

       %if %qupcase(&&missset&i)=NULL %then
           %let missset&i=;
       %else %do;
           %**** check syntax in MISSINGDEF against SWAPVARS ****;
           %if %index(&&missset&i,%str(%')) > 0 and &&vt&i=N %then %do;
              %let err1=&prgname Error: Variable &&swapvar&i is numeric but the missing values in MISSINGDEF have quotes.;
              %let err2=&prgname Error: You have specified SWAPVARS=&swapvars and MISSINGDEF=&missingdef..;
              %let nerr=2;
              %goto exit_impute;
           %end;

           %if %index(&&missset&i,%str(%')) = 0 and &&vt&i=C %then %do;
              %let err1=&prgname Error: Variable &&swapvar&i is character but the missing values in MISSINGDEF are not in quotes.;
              %let err2=&prgname Error: You have specified SWAPVARS=&swapvars and MISSINGDEF=&missingdef..;
              %let nerr=2;
              %goto exit_impute;
           %end;
       %end;
   %end;

   %do i=1 %to &n_misssets;

      %if %length(&&missset&i) > 0 %then %do;

         %if %index(&&missset&i,%str(%')) > 0 %then
            %ds_parse(string=&&missset&i);
         %else %do;
            /***%if %index(%str( )&&missset&i%str( ),%str( )%str(.)%str( )) > 0 %then %do;***/
            %if &&missset&i=%str(.) %then %do;
/***%put hasmiss&i=&&hasmiss&i;***/
               proc freq data=&data;
                  where missing(&&swapvar&i);
                  tables &&swapvar&i/noprint missing out=__tmp1(keep=&&swapvar&i);
               run;
               %let hasmiss&i=%ds_nobs(dataset=__tmp1);
               %let mstring=;
               %ds_missing(dataset=__tmp1,n=&&hasmiss&i,var=&&swapvar&i,vtype=&&vt&i)
               %if &&missset&i ne &mstring %then
                  %let missset&i=&&missset&i &mstring;
            %end;
            %ds_words(string=&&missset&i,delim=%str( ))
         %end;

         %let n_miss&i=&n_var;

%if &debug=1 %then %do;
%put missset&i=&&missset&i;
%put n_miss&i=&&n_miss&i;
%put ;
%end;

         %do j=1 %to &&n_miss&i;

            %if %index(&&missset&i,%str(%')) > 0 %then %do;
               %let cell&j=%str(%')&&cell&j%str(%');

               %if &&cell&j=%str( ) %then
                  %let cell&j=' ';
            %end;

            %let n_missvals=%eval(&n_missvals+1);
            %let missvals=&missvals %unquote(&&cell&j);
            %let missclause&i=&&missclause&i,%unquote(&&cell&j);
            %let missv&i&j=%unquote(&&cell&j);
            %let missval&n_missvals=%unquote(&&cell&j);

%if &debug=1 %then %do;
%put missv&i&j=&&missv&i&j;
%put missval&n_missvals=&&missval&n_missvals;
%put;
%end;

         %end;
         %let missclause&i=%substr(%quote(&&missclause&i),2);
      %end;

%if &debug=1 %then %do;
%put n_missvals=&n_missvals;
%put missclause&i=&&missclause&i.;
%put;
%end;

   %end;

   **** loop to impute one swapvar *****;
   %let swapvars=;
   %local ninclude ;

   %do i = 1 %to &n_swapvars;
      %let nmiss&i=0;
      %if %length(&&missset&i) > 0 %then %do;

         %if %length(&boundary)>0 %then %do;
            proc sort data=&cumdata out=&tmpdsn;
               by &boundary &&swapvar&i;
            run;
            %let cumdata=&tmpdsn;
         %end;

         %****__tmp1 contains missing frequencies****;
         proc freq data=&cumdata;
            where &&swapvar&i in (&&missclause&i.);
            tables &&swapvar&i/missing noprint out=__tmp1(keep=&&swapvar&i percent);
         run;

         %let nmiss&i = %ds_nobs(dataset=__tmp1) ;

         %****no missing. goto next swapvar****;
         %if &&nmiss&i=0 %then %goto next_swapvar;

         %****count imputed swapvars****;
         %let n_imputed=%eval(&n_imputed+1);

         %put %str(                       )**** imputing &&swapvar&i. ****;
         %put;

         %****__tmp1 contains non-missing frequencies****;
         proc freq data=&cumdata;
            %if %length(&boundary)>0 %then %do;
               by &boundary;
            %end;
            where &&swapvar&i not in (&&missclause&i.);
            tables &&swapvar&i/missing noprint out=__tmp1(keep=&boundary &&swapvar&i percent);
         run;
         %if %length(&boundary)>0 %then %do;
            proc summary nway data=__tmp1;
               by &boundary;
               output out=__tmp2(drop=_type_);
            run;

            /***
            proc print data=__tmp1;
               title "DEBUG: __tmp1";
            run;
            proc print data=__tmp2;
               title "__tmp2";
            run;
            ***/

            data _null_;
               retain __max 0;
               if eof then call symput('ninclude',left(put(__max,8.)));
               set __tmp2 end=eof;
               if _freq_ > __max then __max=_freq_;
            run;
            /***%put ninclude=&ninclude;***/

            data __tmp1;
               array __pdf(&ninclude) __pdf1-__pdf&ninclude;
               array __cat(&ninclude) %if %index(&&missset&i,%str(%')) > 0 %then $; __cat1-__cat&ninclude;
               retain i 0 __pdf1-__pdf&ninclude 0 __cat1-__cat&ninclude;
               set __tmp1 ;
               by &boundary;
               i=i+1;
               __pdf(i)=percent/100;
               __cat(i)=&&swapvar&i;
               if last.&last_boundary then do;
                  output;
                  do i = 1 to &ninclude;
                     __pdf(i)=0;
                     %if %index(&&missset&i,%str(%')) > 0 %then __cat(i)=' ';
                     %else __cat(i)=0;
                     ;
                  end;
                  i=0;
               end;
               keep &boundary __pdf1-__pdf&ninclude __cat1-__cat&ninclude;
            run;

            /***
            proc print data=__tmp1;
               title "debug : __tmp1";
               var &boundary __pdf1-__pdf&ninclude;
            run;
            proc print data=__tmp1;
               title "debug: __tmp1";
               var &boundary __cat1-__cat&ninclude;
            run;
            ***/

            data &tmpdsn;
               array __cat(&ninclude) %if %index(&&missset&i,%str(%')) > 0 %then $; __cat1-__cat&ninclude;
               array __pdf(&ninclude) __pdf1-__pdf&ninclude;
               retain seed &seed ;
               merge &cumdata(in=in1) __tmp1(in=in2);
               by &boundary;

               if in1 and not in2 then do;
                  call symput("err1","&prgname Error: Variable &&swapvar&i is all missing in at least one boundary group and cannot be fully imputed.");
                  call symput("nerr","1");
               end;

               if in2;

               if &&swapvar&i in (&&missclause&i) then do;
/***put "before 1 " &&swapvar&i= __pdf1= __pdf2= __cat1= __cat2=;***/
                  call RANTBL(seed,of __pdf1 - __pdf&ninclude,__pos);
                  /***call RANTBL(seed,0.5,0.25,0.50,__pos);***/
/***put "after  1 " &&swapvar&i= __pdf1= __pdf2= __cat1= __cat2= __pos=;***/
                  &&swapvar&i.._I = __cat(__pos);
               end;
               else do;
/***put "before 2 " &&swapvar&i= __pdf1= __pdf2= __cat1= __cat2=;***/
                  &&swapvar&i.._I=&&swapvar&i;
/***put "after  2 " &&swapvar&i= __pdf1= __pdf2= __cat1= __cat2= __pos=;***/
               end;

               LABEL &&SWAPVAR&I.._I="Imputed &&SWAPVAR&I";

               drop seed __pos __pdf1-__pdf&ninclude __cat1-__cat&ninclude;
            run;

            /***
            proc print data=&cumdata (obs=50);
              title "cumdata";
               var  &boundary &&swapvar&i &&swapvar&i.._I __pos __pdf1-__pdf5;
            run;
            ***/
         %end;
         %else %do;

            %let ninclude = %ds_nobs(dataset=__tmp1) ;

            data __tmp1;
               array __pdf(&ninclude) __pdf1-__pdf&ninclude;
               array __cat(&ninclude) %if %index(&&missset&i,%str(%')) > 0 %then $; __cat1-__cat&ninclude;
               retain __pdf1-__pdf&ninclude __cat1-__cat&ninclude;
               if eof then output;
               set __tmp1 end=eof;
               __pdf(_n_)=percent/100;
               __cat(_n_)=&&swapvar&i;
               keep  __pdf1-__pdf&ninclude __cat1-__cat&ninclude;
            run;

            data &tmpdsn;
               array __cat(&ninclude) %if %index(&&missset&i,%str(%')) > 0 %then $; __cat1-__cat&ninclude;
               retain seed &actualseed __pdf1-__pdf&ninclude __cat1-__cat&ninclude;
               set &cumdata;
               if _n_=1 then set __tmp1;
               if &&swapvar&i in (&&missclause&i) then do;
                  call RANTBL(seed,of __pdf1-__pdf&ninclude,__pos);
                  /***call RANTBL(seed,0.5,0.25,0.50,__pos);***/
                  &&swapvar&i.._I = __cat(__pos);
               end;
               else do;
                  &&swapvar&i.._I=&&swapvar&i;
               end;

               /*****
               rename &&swapvar&i = &&swapvar&i.._SAV;
               rename &&swapvar&i.._I = &&swapvar&i;
               *****/

               LABEL &&SWAPVAR&I.._I="Imputed &&SWAPVAR&I";

               drop seed __pos __pdf1-__pdf&ninclude __cat1-__cat&ninclude;
            run;
         %end;

         /***
         proc contents data=&tmpdsn;
         run;

         proc freq data=&tmpdsn;
            tables &&swapvar&i * &&swapvar&i.._SAV/missing ;
         run;
         ***/

         %let cumdata=&tmpdsn;

         %if %upcase(&&linkset&i)=NULL %then
            %let linkset&i=&&swapvar&i;
         %else
            %let linkset&i=&&linkset&i &&swapvar&i;

         %if %upcase(&b_var)=%upcase(&&swapvar&i) %then %do;
            %let saveB_var=&&swapvar&i;
            %let b_var=&&swapvar&i.._I;
         %end;

         %let invars=&invars &&swapvar&i.._I;
         %let prnvars=&prnvars ;
         %let swapvar&i=&&swapvar&i.._I;

      %end;
      %else %do;
      %end;

%next_swapvar:

      %let swapvars=&swapvars &&swapvar&i;

   %end;

   ****re-parsed SWAPVARS=&swapvars****;

   %****none of the swapvars has missing values****;
   %if &n_imputed=0 %then %goto exit_impute;

   ****re-process SWAPVARS related statements****;
   %let i=1;
   %let swp_RENAME=%unquote(&&swapvar&i=__o_&&swapvar&i) ;
   %let swp_IF=%unquote(&&swapvar&i=__o_&&swapvar&i) ;
   %let swp_DROP=__o_%unquote(&&swapvar&i) ;
   %do i=2 %to &n_swapvars;
       %let swapv&i=%unquote(&&swapvar&i);
       %let swp_RENAME= &swp_RENAME %unquote(&&swapvar&i=__o_&&swapvar&i) ;
       %let swp_IF    = &swp_IF and %unquote(&&swapvar&i=__o_&&swapvar&i) ;
       %let swp_DROP  = &swp_DROP __o_%unquote(&&swapvar&i) ;
   %end;

   ****re-parse SWAPCELL****;
   %let swapcell=&boundary &swapvars;
   %ds_words(string=&swapcell,delim=%str( ))
   %let n_cellvar=&n_var;

   %let tmpcelldef=&cell1;
   %let swapcell=&cell1;
   %let scell1=%unquote(&cell1);
   %DO I = 2 %TO &n_cellvar;
      /***%PUT CELL&I = &&cell&i; ***/
      %let tmpcelldef=&tmpcelldef.||&&cell&i.;
      %let swapcell=&swapcell &&cell&i.;
      %let scell&i=%unquote(&&cell&i);
   %END;
%put ***re-parsed SWAPCELL=&swapcell;

   ****re-parse LINKSWAP****;
   %let n_linkvars=0;
   %let linkvars=;

   /****
   %if %index(&linkswap,#)=1 %then
      %ds_words(string=null&linkswap,delim=%str(#));
   %else
      %ds_words(string=&linkswap,delim=%str(#)) ;

   %let n_linksets=&n_var;
   ***/

   %if &n_linksets=0 %then %let n_linksets=&n_swapvars;

%if &debug=1 %then %do;
%put linkswap=&linkswap;
%put n_linksets=&n_linksets;
%put ;
%end;

   %do i=1 %to &n_linksets;

      %ds_words(string=&&linkset&i,delim=%str( ))
      %let n_link&i=&n_var;

%if &debug=1 %then %do;
%put linkset&i=&&linkset&i;
%put n_link&i=&&n_link&i;
%put ;
%end;

      %do j=1 %to &&n_link&i;
         %let n_linkvars=%eval(&n_linkvars+1);
         %let linkvars=&linkvars %unquote(&&cell&j);
         %let linkv&i&j=%unquote(&&cell&j);
         %let linkvar&n_linkvars=%unquote(&&cell&j);

%if &debug=1 %then %do;
%put n_linkvars=&n_linkvars;
%put linkv&i&j=&&linkv&i&j;
%put linkvar&n_linkvars=&&linkvar&n_linkvars;
%put ;
%end;

         /****no need to check variables again****

         %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&&linkv&i&j)%str( )))=0 %then %do;
            %let invars=&invars &&linkv&i&j;
         %end;
         %else %do;
            %let err1=&prgname Error: One of your LINKSWAP - &&linkv&i&j has been used twice.;
            %let err2=&prgname Error: Please check your parameters.;
            %let nerr=2;
         %end;

         ****/
      %end;

%if &debug=1 %then %do;
%put linkvars=&linkvars;
%put n_linkvars=&n_linkvars;
%put;
%end;

   %end;

   %do i=1 %to &n_linkvars;
      %let swp_RENAME= &swp_RENAME %unquote(&&linkvar&i=__o_&&linkvar&i) ;
      /***%let swp_IF    = &swp_IF and %unquote(&&linkvar&i=__o_&&linkvar&i) ; ***/
      %let swp_DROP  = &swp_DROP __o_%unquote(&&linkvar&i) ;
   %end;

   proc datasets nolist;
      delete __tmp1 __tmp2;
   quit;

%exit_impute:

%mend ds_impute;

*****SUBROUTINE COUNTS RECORD NUMBER****;
%macro ds_nobs(dataset=);
   %Let FID = %SysFunc(Open(&DataSet)) ;
   %Let DNL = %SysFunc(Attrn(&FID, NLOBS)) ;
   %Let FID = %SysFunc(Close(&FID)) ;
   &DNL
%Mend ds_nobs;

*****SUBROUTINE ASSEMBLES MISSING VALUSE****;
%macro ds_missing(dataset=,n=,var=,vtype=);
   %local i ;

   %do i = 1 %to &n;
      %local str&i;
   %end;

   data _null_;
      set &dataset;
      %do i = 1 %to &n;
         %if &vtype=C %then
            if _n_=&i then call symput("str&i",left(&var));
         %else
            if _n_=&i then call symput("str&i",left(put(&var,8.)));
         ;
      %end;
   run;

   %do i = 1 %to &n;
      %if %index(&&str&i,%str(.)) = 0 %then
         %let str&i=%str(.)&&str&i;

      %let mstring=&mstring &&str&i ;
   %end;

/***%put mstring=&mstring;   ***/

%Mend ds_missing;

*****SUBROUTINE PARSES MISSINGDEF****;
%macro ds_parse(string=);
   %local i j n nquotes char1;

   %let nquotes=0;
   %let i=1;
   %let n_var=0;
   %let n=%length(%quote(&string));

/***%put string=&string;***/
   %do %while (&i < &n);
      %let char1=%bquote(%substr(&string,&i,1));
/***%put char1=&char1;***/
      %if %bquote(&char1) = %str(%') %then %do;
         %let nquotes=%eval(&nquotes+1);
         %let n_var=%eval(&n_var+1);
         %let j=%eval(&i+1);
         %let cell&n_var=;

         %let char1=%bquote(%substr(&string,&j,1));
         %do %while (%bquote(&char1) ne %str(%'));
             %let cell&n_var = &&cell&n_var%bquote(&char1);
             %let j=%eval(&j+1);
             %let char1=%bquote(%substr(&string,&j,1));
         %end;

/***%put cell&n_var=&&cell&n_var;***/
/***%put;***/
         %let nquotes=%eval(&nquotes+1);
         %let i = %eval(&j+1);
      %end;
      %else %do;
         %let i = %eval(&i+1);
      %end;
   %end;

   %if &nquotes ne 0 %then %do;
    data _null_;
       remain = mod(&nquotes,2);
       if remain ne 0 then do;
          put "unclosed quotes";
       end;
    run;
   %end;

%mend ds_parse;

*****SUBROUTINE PRODUCES REPORTS****;
%MACRO DS_swapmeth2(string=);
   %if &swapmeth ne 2 %then %goto exit_swapmeth2;

   %local i j ;

   %****set formats of SWAPVARS****;

   %do i = 1 %to &n_swapvars;
      %local fm&i ;

       data _null_;
          if _n_ = 1 then set &cumdata (keep=&&swapvar&i);
          vt = vtype(&&swapvar&i);
          call symput("vt&i", vt);
          stop;
       run;

      %if &&vt&i=C > 0 %then %do;
         %let err1=&prgname Error: Variable &&swapvar&i needs to be numeric type for SWAPMETH=2 to work.;
         %let err2=&prgname Error: Please check your parameters.;
         %let nerr=2;
         %goto exit_swapmeth2;
      %end;

      proc freq data=&cumdata;
         where missing(&&swapvar&i);
         tables &&swapvar&i/missing noprint out=__tmp1(keep=&&swapvar&i);
      run;

      %let tmiss=%ds_nobs(dataset=__tmp1);

      %if &tmiss ne 0 %then %do;
         %let err1=&prgname Error: Variable &&swapvar&i cannot have missing value for SWAPMETH=2 to work.;
         %let err2=&prgname Error: Please check your parameters.;
         %let nerr=2;
         %goto exit_swapmeth2;
      %end;
   %end;

%exit_swapmeth2:
%mend ds_swapmeth2;

*****SUBROUTINE PRODUCES REPORTS****;
%MACRO DS_REPORTS(string=);
    %local xxmos xxstratar xxstrata renlist keeplist;
    %local flaglabels flagvars xtraflags;
    %local i j avar vars_analysis n_vars_analysis;

    %let keeplist=&id;
    %let renlist=;
    %do i = 1 %to &n_swapvars;
        /**** %let oldvars=&oldvars &&swapvar&i.; ***/
       %if &&nmiss&i ne 0 %then %let avar=%substr(&&swapvar&i,1,%eval(%length(&&swapvar&i)-2));
       %else %let avar=&&swapvar&i;

       %let keeplist=&keeplist &avar;
       %let renlist=&renlist %unquote(&avar=__o_&avar);
       %let flagvars=&flagvars %unquote(__&avar)_change_flag ;
       %let flaglabels=&flaglabels %unquote(__&avar)_change_flag = "Change flag for %unquote(&avar.) ";
    %end;

    %do i = 1 %to &n_linkvars;
        /**** %let oldvars=&oldvars &&linkvar&i.; ***/
        %if %index(%quote(%str( )%upcase(&swapvars)%str( )),%quote(%str( )%upcase(&&linkvar&i.._I)%str( )))=0 %then %do;
           %let keeplist=&keeplist %unquote(&&linkvar&i..);
           %let renlist=&renlist %unquote(&&linkvar&i..=__o_&&linkvar&i..);
           %let flagvars=&flagvars %unquote(__&&linkvar&i.)_change_flag ;
           %let flaglabels=&flaglabels %unquote(__&&linkvar&i.)_change_flag = "Change flag for %unquote(&&linkvar&i.) ";
        %end;
    %end;

     /*** forgot what this is for.  comment out for now ***/
     /***
    %if &n_cellvar > &n_boundvar and &n_boundvar ne 0 %then %do;

%if &debug=1 %then %do;
%put n_cellvar=&n_cellvar;
%put n_boundvar=&n_boundvar;
%end;

    %do i = %eval(&n_cellvar - &n_boundvar) %to &n_cellvar;
        %if &i = &n_cellvar %then
           %let xtraflags = &xtraflags %unquote(__&&cell&i.)_change_flag;
        %else
           %let xtraflags = &xtraflags %unquote(__&&cell&i.)_change_flag * ;
    %end;
    %end;
    %put xtraflags=&xtraflags;
    ***/

    %if &mos ne __mos %then %do;
        %let xxmos=&mos;
    %end;

    %if &stratum ne __stratum %then %do;
        %let xxstratar=&stratum.r;
        %let xxstrata=&stratum;
    %end;

    /***
    data &holder;
       set &holder;
       by &id;
       rename &renlist. ;
    run;
    ***/

    proc sort data=&holder out=&holder;
       by &id;
    run;

    data __swap;
       merge &tmpdsn &holder(keep=&keeplist rename=(&renlist));
       by &id;
       ***if &sampflag ne ' ';
       %do i = 1 %to &n_swapvars;
          %if &&nmiss&i ne 0 %then %let avar=%substr(&&swapvar&i,1,%eval(%length(&&swapvar&i)-2));
          %else %let avar=&&swapvar&i;

          if %unquote(__o_&avar) ne %unquote(&avar) then do;
             %unquote(__&avar.)_change_flag = '1';
             if &sampflag ne ' ' then __overall_change_flag="2";
             else __overall_change_flag="1";
          end;
          else
             %unquote(__&avar)_change_flag = '0';
       %end;
       %do i = 1 %to &n_linkvars;
          %if %index(%quote(%str( )%upcase(&swapvars)%str( )),%quote(%str( )%upcase(&&linkvar&i.._I)%str( )))=0 %then %do;
             if %unquote(__o_&&linkvar&i) ne %unquote(&&linkvar&i) then do;
                %unquote(__&&linkvar&i.)_change_flag = '1';
                if &sampflag ne ' ' then __overall_change_flag="2";
                else __overall_change_flag="1";
             end;
             else
                %unquote(__&&linkvar&i.)_change_flag = '0';
          %end;
       %end;
       label &flaglabels. ;
    run;
/***
proc contents data=__swap;
title "__swap";
run;
proc contents data=&out;
title "&out";
run;
proc contents data=__holder;
title "__Holder";
run;
***/
    /*** output to debug file if requested ***/
    %if &tempfile ne %then %do;
        data &tempfile.;
           set __swap;
        run;
    %end;

    %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
       /* task 1b added August 2011 */
       Ods listing close;
       proc surveyfreq data=&holder ;
          cluster &varunit;
          strata &varstrat;
          ods output oneway=__responsetable(drop=Frequency StdDev WgtFreq Percent);
          tables &swapvars &linkvars;
          weight &WGT;
       run;
       ods listing;
       /*
       proc contents data=__responsetable;
       run;
       proc print data=__responsetable;
       run;
       */

       %if &keyout ne %then %do;
          /* task 1b added August 2011 */
          Ods listing close;
          proc surveymeans data=&holder ;
             cluster &varunit;
             strata &varstrat;
             ods output domain=__DomainTable(drop=LowerCLMean UpperCLMean N Mean);
             domain &swapvars &linkvars;
             var &keyOut;
             weight &WGT;
             label
             %do i=1 %to &n_swapvars;
             &&swapvar&i.="&&swapvar&i."
             %end;
             %do i = 1 %to &n_linkvars;
             &&linkvar&i.="&&linkvar&i."
             %end;
             ;
          run;
          ods listing;
          /*
          proc contents data=__DomainTable;
          run;
          proc print data=__DomainTable;
          run;
          */
       %end;
    %end;

    /*** process user only tables ***/
    /*** for user only use lim=300 instead of lim=&maxcat ***/

    %ds_table0

    %local hast01 hast1 i;
    %local flgU flgU2 flgW flgW2;
    %do i=1 %to &n_keyouts;
       %local flgM&i.1 flgM&i.2;
    %end;

    %let hast01=0;
    %do i = 1 %to &n_swapvars;
       %if &&nmiss&i ne 0 %then %let avar=%substr(&&swapvar&i,1,%eval(%length(&&swapvar&i)-2));
       %else %let avar=&&swapvar&i;

    title4 "Aggregated Level -- Changes to Swapped Variable SWAPVARS=&avar";

       %ds_table01(var=&avar,keyout=&keyout,lim=300,user=y,varsrc=s);

       %do j=1 %to &&n_link&i;
          %if &&linkv&i&j ne &avar %then %do;
    title4 "Aggregated Level -- Changes to Swapped Variable LINKSWAP=&&linkv&i&j";
             %ds_table01(var=&&linkv&i&j,keyout=&keyout,lim=300,user=y,varsrc=l)
          %end;
       %end;
    %end;

    %ds_table02(keyout=&keyout,print=y,lim=300,user=y)

    /*** process DRB Chair tables ***/
    %if %length(&swapvars)>40 %then %let chop1=%substr(&swapvars,1,40)...;
    %else %let chop1=&swapvars;
    title3 "Supplemental Tables for DRB Chair Only";
    title4 "Percent of Records Changed Among Swapped Variables in SWAPVARS";

    %do i = 1 %to &n_swapvars;
       %if &&nmiss&i ne 0 %then %let avar=%substr(&&swapvar&i,1,%eval(%length(&&swapvar&i)-2));
       %else %let avar=&&swapvar&i;

       %ds_table1(var=&avar);
    %end;
    %ds_table1(var=Overall)
    %ds_table1(print=y)

    %let hast1=0;
    %do i = 1 %to &n_linkvars;
        %if %index(%quote(%str( )%upcase(&swapvars)%str( )),%quote(%str( )%upcase(&&linkvar&i.._I)%str( )))=0 %then %do;
           %ds_table1(var=&&linkvar&i);
           %let hast1=1;
        %end;
    %end;
    %if &hast1 ne 0 %then %do;

        %if %length(&linkswap)>40 %then %let chop1=%substr(&linkswap,1,40)...;
        %else %let chop1=&linkswap;
        title4 "Percent of Records Changed Among Swapped Variables in LINKSWAP";

        %ds_table1(print=y)
    %end;

    /*** process tables for DRB members ***/
    title3 "Supplemental Tables for DRB Members";

    %let hast01=0;
    %do i = 1 %to &n_swapvars;

       %if &&nmiss&i ne 0 %then %let avar=%substr(&&swapvar&i,1,%eval(%length(&&swapvar&i)-2));
       %else %let avar=&&swapvar&i;

    title4 "Aggregated Level -- Changes to Swapped Variable SWAPVARS=&avar";
       %ds_table01(var=&avar,keyout=&keyout, lim=&maxcat, varsrc=s)

       %do j=1 %to &&n_link&i;
          %if &&linkv&i&j ne &avar %then %do;
    title4 "Aggregated Level -- Changes to Swapped Variables in LINKSWAP=&&linkv&i&j";
             %ds_table01(var=&&linkv&i&j,keyout=&keyout, lim=&maxcat,varsrc=l)
          %end;
       %end;
    %end;

    %ds_table02(keyout=&keyout,print=y,lim=&maxcat)

    %ds_table2()

    %ds_measure()

%MEND DS_REPORTS;

*****SUBROUTINE PRODUCE USER ONLY REPORTS****;
%MACRO DS_TABLE0;

    %local localDSN;

    title3 "User Only Output";

    proc format;
       value $ sfmt " "="not selected"
                    "c"="certainty"
                    "n"="selected";
       value $ ffmt " "="not swapped"
                    "1"="donor"
                    "2"="target";
       value $ cfmt "0"="no change"
                    "1"="change";
    run;

    %local i j pos;
    %do i =1 %to &n_swapvars;
       %if &&nmiss&i ne 0 %then %do;
          %let pos=%index(&&swapvar&i,_I);
          proc freq data=__swap;
             tables %substr(&&swapvar&i,1,%eval(&pos-1))/noprint out=__tmp1;
          run;

          %let j= %ds_nobs(dataset=__tmp1);
          %if &j <= &maxcat %then %do;
             proc freq data=__holder;
                tables &&swapvar&i * %substr(&&swapvar&i,1,%eval(&pos-1))/list missing;
                title4 "Check on Imputed Variables";
             run;
          %end;
          %else %do;
             data _null_;
                FILE PRINT N=PS LS=&LS;
                PUT //
                "                    "
                "The frequency to compare the imputed variable with the original variable for variable %substr(&&swapvar&i,1,%eval(&pos-1))"/
                "                    "
                "was not generated because it has %trim(&j) levels which exceeds MAXCAT=&maxcat.."/
                "                    "
                "Increase the value of MAXCAT to allow the report to be printed.";
             run;
          %end;
       %end;
    %end;

    proc freq data=__swap;
       *where &sampflag ne ' ';
       title4 "Frequency of Change Flags";
       tables &flagvars./missing list;
       format &flagvars $cfmt.;
    run;

    %if %length(&xtraflags) > 0 %then %do;
    proc freq data=__swap;
       title4 "COMPARISON OF SWAP FLAGS - UNBOUNDED VARIABLES";
       tables &xtraflags./missing list;
    run;
    %end;

    proc freq data=__swap ;
       title4 "Sampling Result";
       tables &sampflag*__overall_change_flag/missing list noprint out=__hoho;
       format &sampflag $sfmt. __overall_change_flag $ffmt.;
    run;

    proc print data=__hoho split="#";
       label &sampflag ="Sampling#Flag";
       label __overall_change_flag="Swapping#Flag";
       sum Count;
    run;

    /*** added 3/15/2005 ***/
    %if &stratum ne __stratum %then %do;
      proc freq data=__swap;
         tables &stratum*&sampflag/list missing noprint out=__hoho(keep=&stratum &sampflag count rename=(count=__ind));
         format &sampflag $sfmt.;
      run;
      proc freq data=__swap;
         tables &stratum/list noprint out=__tmp1(keep=&stratum count rename=(count=__cat));
      run;
      data __hoho;
         merge __hoho __tmp1;
         by &stratum;
         __p = right(put(__ind/__cat * 100,5.2))||"%";
         __q = __ind/__cat * 100;
         drop __cat;
      run;
      proc print data=__hoho split="#";
         var &stratum &sampflag __ind __p ;
         title5 "By STRATUM=&stratum";
         label &sampflag ="Sampling#Flag";
         label __ind="Frequency";
         label __p="Percent of Stratum#Frequency";
         sum __ind;
      run;
    %end;

    /*** Tom scratched this out
    proc print data=&swapsap label;
       title4 "IDs of the Selected Cases and Their Swap Partners";
       label __s&id="Selected ID"
             &id = "Swap Partner ID";
    run;

    proc print data=__swap label;
       where &sampflag ne ' ';
       ***var &id &swapcell &celln &swapvars &wgt &xxmos &xxstrata;
       var &invars ;
       title4 "Swapped Results";
    RUN;
    ***/

    %let localDSN=__hoho __tmp1;

    %if &listpair2=0 %then %goto exit_table0;

    %let localDSN=&localDSN __tmp2 __tmp3;

    %if %upcase(&listpair1)=S %then %do;
       data _null_;
          call symput("skipint",left(put(100/(&listpair2*100),8.0)));
       run;
       /*%put skip interval for listpair=&listpair is &skipint;*/
    %end;

    data __tmp1;
       set &swapsap;
       retain __ord 0;
       __ord+1;
      %if %upcase(&listpair1)=S %then %do;
         %if &skipint ne 1 %then %do;
            if mod(_n_,&skipint)=1 then output __tmp1;
         %end;
      %end;
    run;

    proc sort data=__tmp1(drop=&id rename=(__s&id=&id)) out=__tmp2;
       by &id;
    run;

    data __tmp2;
       merge &tmpdsn(in=in1) __tmp2(in=in2);
       by &id;
       if in2;
       __sec=2;

       keep &invars. __ord __sec %if &useRandom ne 0 %then __group; ;
    run;

    *proc print data=__tmp2;
    *   var &id &swapcell &celln &swapvars &wgt &xxmos  &xxstrata __ord __sec;
    *   title4 "SAMPLED CASES WITH THE ORIGINAL VALUES";
    *run;

    proc sort data=__tmp1(drop=__s&id) out=__tmp3;
       by &id;
    run;

    data __tmp3;
       merge &tmpdsn(in=in1) __tmp3(in=in2);
       by &id;
       if in2;
       __sec=3;

       keep &invars. __ord __sec  %if &useRandom ne 0 %then __group;;
    run;

    *proc print data=__tmp3;
    *   var &id &swapcell &celln &swapvars &wgt &xxmos &xxstrata __ord __sec;
    *   title4 "SWAP PARTNERS WITH THE ORIGINAL VALUES";
    *run;

    data __tmp2;
       set __tmp2 __tmp3 ;
    run;

    proc sort data=__tmp2;
       by &id;
    run;

    data __tmp2;
       merge __tmp2(in=in1) __swap(in=in2 keep=&id &flagvars);
       by &id;
       if in1;
    run;

    proc sort data=__tmp2;
       by __ord __sec;
    run;

    **** subset ****;
    %if %upcase(&listpair1)=B %then %do;
    data __tmp1(keep=__ord);
       set __tmp2;
       retain __topb __butb __topw __butw 0;
       by __ord;
       if __sec=2 then do; __topb=&b_var; __topw=&wgt; end;
       if __sec=3 then do; __butb=&b_var; __butw=&wgt; end;
       if last.__ord then do;
          __abs = abs((__topw * (__butb - __topb) + __butw * (__topb - __butb))
                    / (__topw * __topb + __butw * __butb));
          if __abs > &listpair2 then output;
       end;
    run;
    data __tmp2;
       merge __tmp2(in=ina) __tmp1(in=ink);
       by __ord;
       if ink;
    run;
    %end;

    proc print data=__tmp2 label &showobs;
       **var &id &swapcell &celln &swapvars &wgt &xxmos &xxstrata;
       **var &invars &flagvars.;
       var /***%if &useRandom ne 0 %then __group;***/ &prnvars &flagvars;
       by __ord;
       label __ord="Pair";
       title4 "DataSwap Results by Pairs";
       footnote1 "Top Record is the Selected Sample. Bottom Record is the Swap Partner";
      %if &n_imputed ne 0 %then %do;
       footnote2 "Note: Under the option IMPUTE = Y, only the original variables and values are shown  ";
       footnote3 "      and the change flags depend on the imputed values (not shown). For instance,   ";
       footnote4 "      one record in a pair may have a missing value, and the other may be nonmissing.";
       footnote5 "      If the imputed value is the same as the other record's nonmissing original     ";
       footnote6 "      value, then the original data is not swapped. Otherwise, it is swapped.        ";
      %end;
    run;
    footnote1;

%exit_table0:

    proc datasets nolist;
       delete &localDSN;
    quit;

%MEND DS_TABLE0;

*****SUBROUTINE PRODUCE AGGREGATED TABLES****;
%MACRO DS_TABLE01(var=,keyout=,lim=,user=,varsrc=);
    %local i j k keyoutlist0;
    %let flg1=;
    %let flg2=;
    %let flg3=;
    %let flg4=;
    %let flg5=; /*flag significant ratio */
    %let flg6=; /*flag significant ratio */

    %local blanknote1 blanknote2;
    %if %length(&user)>0 %then %do;
       %let blanknote1=(the limit for User Only output);
       %let blanknote2=Create a version of &var with less than 300 levels, and specify it as a LINKSWAP variable to allow the report to be printed;
    %end;
    %else %do;
       %let blanknote2=Increase the value of MAXCAT to allow the report to be printed;
    %end;

    proc freq data=&holder;
       tables &var/out=__i(keep=&var percent
          rename=(percent=__ube))  noprint;
    run;
    proc freq data=&tmpdsn;
       tables &var/out=__j(keep=&var percent count
          rename=(percent=__uaf count=__count)) noprint;
    run;
    proc freq data=&holder;
       weight &wgt;
       tables &var/out=__k(keep=&var percent
          rename=(percent=__wbe))  noprint;
    run;
    proc freq data=&tmpdsn;
       weight &wgt;
       tables &var/out=__l(keep=&var percent
              rename=(percent=__waf)) noprint;
    run;

    data _null_;
       if eof then call symput("thisn",left(put(_n_-1,8.0)));
       set __i end = eof;
    run;

    %if &thisn > &lim %then %do;
       data _null_;
          FILE PRINT N=PS LS=&LS;
          PUT //
          "          "
          "Report for &&VAR was not generated because it has %trim(&THISN) levels which exceeds MAXCAT=&LIM.&blanknote1"/
          "                    "
          "&blanknote2";
       run;
       %goto end_table01;
    %end;

    %local wgt_mean in_mean label_mean flag_mean;
    %let n=0;

    %let hast01=1;

    %if &keyout ne %then %do;
       proc means nway data=&holder noprint;
          class &var;
          weight &wgt;
          var &keyout;
          output out=__m(drop=_freq_ _type_) mean=__mbe1-__mbe&n_keyouts;
       run;
       proc means nway data=&tmpdsn noprint;
          class &var;
          weight &wgt;
          var &keyout;
          output out=__n(drop=_type_) mean=__maf1-__maf&n_keyouts;
       run;
       %let wgt_mean= __m(in=in5) __n(in=in6);
       %let in_mean = %str( and in5 and in6);

       %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
       data __o(keep=&var  __mSEbe1-__mSEbe&n_keyouts) ;
          array __mSEbe(&n_keyouts) __mSEbe1-__mSEbe&n_keyouts;
          retain __mSEbe1-__mSEbe&n_keyouts ;
          set __DomainTable(
              keep=&var DomainLabel VarName StdErr
              rename=(Stderr=__Stderr DomainLabel=__DomainLabel VarName=__VarName)
              where=(__DomainLabel="&var"));
          by &var;
          if first.&var. then __i=1;

          __mSEbe(__i)=__stderr;
          __i+1;

          if last.&var. then output;
       run;
       %end;

       %let label_mean=;
       %do i=1 %to &n_keyouts;
          %let label_mean=&label_mean.
             %str(__mbec&i="Weighted Mean#of &&keyout&i#Before#Swapping"
                  __mafc&i="Weighted Mean#of &&keyout&i#After#Swapping");
       %end;
       %let label_mean=%str(label &label_mean. ;);

       /*break KEYOUT list into sublists*/
       %let nlist=0;
       %if &n_keyouts=1 %then %do;
          %let keyoutlist0=__mbec1 __mafc1;
       %end;
       %else %if n_keyouts > 1 %then %do;
          %let j=1;
          %let k=4;
          %do %while (&j<=&n_keyouts);
             %if &k=4 %then %do;
                %let nlist = %eval(&nlist+1);
                %let keyoutlist&nlist=;
                %let k=1;
             %end;
             %let keyoutlist&nlist=&&keyoutlist&nlist __mbec&j __mafc&j;
             %let j=%eval(&j+1);
             %let k=%eval(&k+1);
          %end;
       %end;
    %end;

    data __w;
       merge __i(in=in1) __j(in=in2) __k(in=in3) __l(in=in4) &wgt_mean
      %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
             __responsetable
             (keep=&var Stderr _Skipline Table
              rename=(Stderr=__wSEbe _skipline=__skipline table=__table)
              where=(__Table="Table &var" and __Skipline ne "1") in=in7)
         %if &keyout ne %then %do;
             __o(in=in8)
         %end;
      %end;
       ;
       by &var ;

       /* talked with Tom. Decided to show all categories anyway */
       /* some datasets may have missing category*/
       *****if not (in1 and in2 and in3 and in4 &in_mean) then abort;

       __ucount=put(__count,8.0);
       if __ube ne 0 and abs((__uaf-__ube)/__ube) > &tolflag1 and
          __count > &tolflag2 then do;
          __ubec=put(__ube,8.4);
          __uafc=put(__uaf,8.4)||"*";
          call symput("flg1","1");
       end;
       else do;
          if __ube=0 and __uaf ne 0 then do;
             __ubec=put(__ube,8.4);
             __uafc=put(__uaf,8.4)||"~";
             call symput("flg2","1");
          end;
          else do;
             __ubec=put(__ube,8.4);
             __uafc=put(__uaf,8.4);
          end;
       end;

       if __wbe ne 0 and abs((__waf-__wbe)/__wbe) > &tolflag1 and
          __count > &tolflag2 then do;
          __wbec=put(__wbe,8.4);
          __wafc=put(__waf,8.4)||"*";
          call symput("flg1","1");
       end;
       else do;
          if __wbe=0 and __waf ne 0 then do;
             __wbec=put(__wbe,8.4);
             __wafc=put(__waf,8.4)||"~";
             call symput("flg2","1");
          end;
          else do;
             __wbec=put(__wbe,8.4);
             __wafc=put(__waf,8.4);
          end;
       end;

       %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
       __wSEaf=sqrt((__wSEbe)**2+(__wbe-__waf)**2);
       if (__wSEbe ne 0) then do;
          __wSE_ratio= __wSEaf/__wSEbe;
          if __wSE_ratio > &tolflag4 and __count > &tolflag2 then do;
             __wSE_ratioC=put(__wSE_ratio,8.6)||"@";
             call symput("flg5","1");
          end;
          else __wSE_ratioC=put(__wSE_ratio,8.6);
       end;
       label __wSEbe="Estimated#Standard#Errors#Before#Swapping"
             __wSEaf="Estimated#Standard#Errors#After#Swapping"
             __wSE_ratio="Ratio of#Estimated#Standard Errors#(After/Before)"
             __wSE_ratioC="Ratio of#Estimated#Standard Errors#(After/Before)"
             ;
       %end;

       drop __uaf __ube __waf __wbe __count;

       %if &keyout ne %then %do;
       %do i = 1 %to &n_keyouts;
       if __mbe&i ne 0 and abs((__maf&i-__mbe&i)/__mbe&i) > &tolflag1 and
          __count > &tolflag2 then do;
          __mbec&i=put(__mbe&i,8.4);
          __mafc&i=put(__maf&i,8.4)||"*";
          call symput("flg3","1");
       end;
       else do;
          if __mbe&i = 0 and __maf&i ne 0 then do;
             __mbec&i=put(__mbe&i,8.4);
             __mafc&i=put(__maf&i,8.4)||"~";
             call symput("flg4","1");
          end;
          else do;
             __mbec&i=put(__mbe&i,8.4);
             __mafc&i=put(__maf&i,8.4);
          end;
       end;
       drop __mbe&i __maf&i _freq_;

       %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
        __mSEaf&i=sqrt((__mSEbe&i)**2+(__mbe&i-__maf&i)**2);
        if (__mSEbe&i ne 0) then do;
           __mSE_ratio&i= __mSEaf&i/__mSEbe&i;
           if __mSE_ratio&i>&tolflag4 and __count > &tolflag2 then do;
              __mSE_ratio&i.C=put(__mSE_ratio&i,8.6)||'@';
              call symput('flg6','1');
           end;
           else __mSE_ratio&i.C=put(__mSE_ratio&i,8.6);
        end;
        label __mSEbe&i="Estimated#Standard#Errors#Before#Swapping"
              __mSEaf&i="Estimated#Standard#Errors#After#Swapping"
              __mSE_ratio&i="Ratio of Estimated#Standard Errors#(After/Before)"
              __mSE_ratio&i.C="Ratio of Estimated#Standard Errors#(After/Before)"
              ;
       %end;
       %end;
       %end;

    run;

    proc print data=__w split="#" &showobs;
       var &var __ucount __ubec __uafc __wbec __wafc
       %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
       __wSEbe __wSEaf __wSE_ratioC
       %end;
       ;
       label __ucount="Sample#Size";
       label __ubec="Unweighted#Percents#Before#Swapping";
       label __uafc="Unweighted#Percents#After#Swapping";
       label __wbec="Weighted#Percents#Before#Swapping";
       label __wafc="Weighted#Percents#After#Swapping";
      /*%if &flg1=1 %then %do;*/
       %let n=%eval(&n+1);
       footnote&n "* denotes absolute relative difference exceeds &tolflag1 and sample size exceeds &tolflag2";
      /*%end;*/
      /*%if &flg2=1 %then %do;*/
       %let n=%eval(&n+1);
       footnote&n "~ denotes value was zero before swapping and non-zero after swapping";
      /*%end;*/
      /*%if &flg5=1 %then %do;*/
       %let n=%eval(&n+1);
       footnote&n "@ denotes SE ratios exceeds &tolflag4 and sample size exceeds &tolflag2";
      /*%end;*/

    run;
    footnote1;

   %if &keyout ne %then %do;

    /* replaced with new style output */
    /*
    %do i = 1 %to &nlist;
    proc print data=__w split="#" &showobs;
       var &var &&keyoutlist&i;
       &label_mean.
    run;
    %end;
    */

    data _null_;
       if _n_ = 1 then set __w(keep=&var);
       call symput("v",left(vtype(&var)));
    run;

    /* transpose dataset for nicer output*/
    data __w;
       set __w;
       by &var;
       length __keyout $ 32 __value $ 9
       %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
       __SE  8 __ratio $ 9
       %end;
       ;

      %do i=1 %to &n_keyouts;
       __stage ="Before";
       __keyout="&&keyout&i";
       __value = __mbec&i;
       %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
       __SE=__mSEbe&i;
       __ratio = __mSE_ratio&i.C; /*put( __mSE_ratio&i,9.5);*/
       %end;
       %if &i=1 %then %do;
         __n=__ucount;
         %if &v=C %then %do;
         __var=&var;
         %end;
         %else %do;
         __var=put(&var,8.0);
         %end;
       %end;
       %else %do;
         __n="";
         __var="";
       %end;
       output;
       __stage = "After";
       __keyout="";
       __value = __mafc&i;
       %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
       __SE = __mSEaf&i;
       __ratio = '';
       %end;
       __n="";
       __var="";
       output;
      %end;

       keep __keyout __var __n __value __stage
      %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
       __SE __ratio
      %end;
       ;
    run;

    %let n=0;

    proc print data=__w split="#" noobs;
       var __var __n __keyout __stage __value
      %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
       __SE __ratio
      %end;
       ;
       label __n="N"
             __var="&var"
             __keyout="KEYOUT"
             __stage="Before/After#Swapping"
             __value="Weighted Mean"
            %if %length(&varstrat)>0 and %length(&varunit)>0 %then %do;
             __SE="Estimated#Standard Errors"
             __ratio="Ratio of Estimated#Standard Errors#(After/Before)"
            %end;
             ;

      /*%if &flg3=1 %then %do;*/
       %let n=%eval(&n+1);
       footnote&n "* denotes absolute relative difference exceeds &tolflag1 and sample size exceeds &tolflag2";
      /*%end;*/
      /*%if &flg4=1 %then %do;*/
       %let n=%eval(&n+1);
       footnote&n "~ denotes value was zero before swapping and non-zero after swapping";
      /*%end;*/
      /*%if &flg6=1 %then %do;*/
       %let n=%eval(&n+1);
       footnote&n "@ denotes SE ratios exceeds &tolflag4 and sample size exceeds &tolflag2";
      /*%end;*/
    run;
    footnote1;
   %end;


    %ds_table02(var=&var,keyout=&keyout,lim=&lim,user=&user,varsrc=&varsrc)


%end_table01:

    proc datasets nolist;
       delete __i __j __k __l
          %if &thisn <= &lim %then %do; __w
              %if &keyout ne %then __m __n;
          %end;
          %if %length(&varstrat)>0 and %length(&varunit)>0 and &n_keyouts>0 %then
          __o;
       ;
    quit;

%MEND DS_TABLE01;

*****SUBROUTINE PRODUCE SORTED AGGREGATED TABLES****;
%MACRO DS_TABLE02(var=,keyout=,print=,lim=,user=,varsrc=);
   %local i ;
   %if &print= %then %do;
    data __t1(keep=__var __val __ucount __ube __uaf __meac __mea);
       length __var $ 24 __val $ 24 __ucount $8 __ube __uaf 8 __meac $10;
       merge __i(in=in1) __j(in=in2);
       by &var;
       if not in1 and in2 then abort;

       __var = "&var";
       __val = COMPBL(left(&var));
       __ucount=put(__count,8.0);
       if __ube ne 0 then __mea = abs((__uaf-__ube)/__ube);

       if __mea > &tolflag1 and __ucount > "&tolflag2" then do;
          __meac=right(put(__mea,9.6)||"*");
          call symput("flgU","1");
       end;
       else do;
          if __ube=0 and __uaf ne 0 then do;
             __meac=right(put(__mea,9.6)||"~");
             call symput("flgU2","1");
          end;
          else do ;
             __meac=put(__mea,9.6);
          end;
       end;

    run;

    proc append data=__t1 base=__ap1;
    run;

    data __t2(keep=__var __val __wcount __wbe __waf __meac __mea __varsrc __count);
       length __var $ 24 __val $ 24 __wcount $8 __wbe __waf 8 __meac $10;
       merge __k(in=in1) __l(in=in2) __j(in=in3 keep=&var __count);
       by &var;
       /**if not in1 and in2 then abort;**/

       __var = "&var";
       __val = COMPBL(left(&var));
       __wcount=put(__count,8.0);
       __varsrc="&varsrc";
       if __wbe ne 0 then __mea = abs((__waf-__wbe)/__wbe);

       if __mea > &tolflag1 and __count > &tolflag2 then do;
          __meac=right(put(__mea,9.6)||"*");
          call symput("flgW","1");
       end;
       else do;
          if __wbe=0 and __waf ne 0 then do;
             __meac=right(put(__mea,9.6)||"~");
             call symput("flgW2","1");
          end;
          else do;
             __meac=put(__mea,9.6);
          end;
       end;
    run;

    proc append data=__t2 base=__ap2;
    run;

    %if &keyout ne %then %do;
    %do i=1 %to &n_keyouts;
    data __t3(keep=__var __val __cnt __mbe __maf __meac __mea __varsrc);
       length __var $ 24 __val $ 24 __cnt __mbe __maf 8 __meac $10;
       merge __m(in=in1 rename=(__mbe&i=__mbe)) __n(in=in2 rename=(__maf&i=__maf));
       by &var;
       if not in1 and in2 then abort;

       __var = "&var";
       __val = COMPBL(left(&var));
       __varsrc="&varsrc";
       __cnt = _freq_;
       if __mbe ne 0 then __mea = abs((__maf-__mbe)/__mbe);

       if __mea > &tolflag1 and __cnt > &tolflag2 then do;
          __meac=right(put(__mea,9.6)||"*");
          call symput("flgM&i.1","1");
       end;
       else do;
          if __mbe = 0 and __maf ne 0 then do;
             __meac=right(put(__mea,9.6)||"~");
             call symput("flgM&i.2","1");
          end;
          else do;
             __meac=put(__mea,9.6);
          end;
       end;

    run;

    proc append data=__t3 base=__ap3_&i;
    run;
    %end;
    %end;
   %end;
   %else %do;
    %if &hast01=0 %then %goto end_table02;

    proc sort data=__ap1;
       by descending __mea;
    run;
    proc sort data=__ap2;
       by descending __mea;
    run;
    /*** since this always come out as 0, Tom said to scratch it.
    proc print data=__ap1 split="#" &showobs;
       var __var __val __ucount __ube __uaf __meac ;
       title4 "Unweighted Percents Sorted by Relative Difference in SWAPVARS and LINKSWAP";
       label __ube="Unweighted#Percents#Before#Swapping";
       label __uaf="Unweighted#Percents#After#Swapping";
       label __ucount="Sample#Size";
       label __var="Variable";
       label __val="Value";
       label __meac="Absolute#Relative#Difference";
       footnote1 "Only Absolute Relative Differences > 0 are shown";
    run;
    ***/
    %let n=1;
    proc print data=__ap2(where=( __mea > 0)) split="#" &showobs;
       var __var __val __wcount __wbe __waf __meac ;
       title4 "Weighted Percents Sorted by Relative Difference in SWAPVARS and LINKSWAP";
       label __wbe="Weighted#Percents#Before#Swapping";
       label __waf="Weighted#Percents#After#Swapping";
       label __wcount="Sample#Size";
       label __var="Variable";
       label __val="Value";
       label __meac="Absolute#Relative#Difference";
       footnote1 "Only Absolute Relative Differences > 0 are shown";
      /*%if &flgW=1 %then %do;*/
       %let n=%eval(&n+1);
       footnote&n "* denotes absolute relative difference exceeds &tolflag1 and sample size exceeds &tolflag2";
      /*%end;*/
      /*%if &flgW2=1 %then %do;*/
       %let n=%eval(&n+1);
       footnote&n "~ denotes value was zero before swapping and non-zero after swapping";
      /*%end;*/
    run;
    footnote1;

    %if &keyout ne %then %do;
    %do i = 1 %to &n_keyouts;
    %let n=1;
    proc sort data=__ap3_&i;
       by descending __mea;
    run;
    proc print data=__ap3_&i(where=(__mea > 0))  split="#" &showobs;
       var __var __val __cnt __mbe __maf __meac ;
       title4 "Weighted Means Sorted by Relative Difference in SWAPVARS and LINKSWAP";
       label __mbe="Weighted#Mean of &&keyout&i#Before#Swapping";
       label __maf="Weighted#Mean of &&keyout&i#After#Swapping";
       label __var="Variable";
       label __val="Value";
       label __cnt="Sample#Size";
       label __meac="Absolute#Relative#Difference";
       footnote1 "Only Absolute Relative Differences > 0 are shown";
      /*%if &&flgM&i.1=1 %then %do;*/
       %let n=%eval(&n+1);
       footnote&n "* denotes absolute relative difference exceeds &tolflag1 and sample size exceeds &tolflag2";
      /*%end;*/
      /*%if &&flgM&i.2=1 %then %do;*/
       %let n=%eval(&n+1);
       footnote&n "~ denotes value was zero before swapping and non-zero after swapping";
      /*%end;*/
    run;
    footnote1;
    %end;
    %end;


    /*beginning of plotting, if DRB members*/
    %if &user= %then %do;

    /* task 1c added August 2011 */
    /* do weighted percent plots */
    /* include SWAPVARS only */

    %local Min Max;

    proc sql noprint;
       select min(__wbe), max(__wbe), min(__waf), max(__waf) into :minbe, :maxbe, :minaf, :maxaf
       from __ap2(where=(__varsrc="s" and __count > &tolflag2))
       ;
    quit;

    data _null_;
      call symput("Min", left(put(min(&minbe,&minaf),8.6)));
      call symput("Max", left(put(max(&maxbe,&maxaf),8.6)));
    run;

    data __g;
       if end then do; __min=&min; __max=&max; output; end;
       set __ap2(where=(__varsrc="s" and __count > &tolflag2)) End=end;
       output;
    run;

    ods listing close;
    options nonumber;
    ods graphics on/border=off ;
    ods &graphtype file="&program_path.&program_prefix._PLOT_PCT_&program_suffix.&sequence..&graphtype"
    %if &usedpi ne  and %upcase(&graphtype)=PDF %then dpi=&usedpi;  ;

    Title3 "Graphs for DRB Members";
    Title4 "Weighted Percents Before and After Swapping";

    proc sgplot data=__g;
       scatter x=__wbe y=__waf / group=__var /*markerattrs=(size=5 color=blue)*/;
       vector x=__max y=__max / xorigin=__min yorigin=__min noarrowheads;
       xaxis label="Before Swapping" min=&min max=&max;
       yaxis label="After Swapping" min=&min max=&max;
       label __wbe="Before";
       label __waf="After";
       label __var="Swapvars";
       footnote1 "Symbols were shown only if cell sample sizes exceed &tolflag2";
       footnote2 j=right "&program_path.&program_prefix._PLOT_PCT_&program_suffix.&sequence..&graphtype";
    run;
    footnote1;
    options number LineSize=&ls;

    /*
    ods &graphtype close;
    ods listing;
    */

    /* task 1c added August 2011 */
    /* do weighted mean plots, one plot per KEYOUT */
    /* include SWAPVARS only */
    %if &keyout ne %then %do;
    %do i = 1 %to &n_keyouts;

    proc sql noprint;
       select min(__mbe), max(__mbe), min(__maf), max(__maf) into :minbe, :maxbe, :minaf, :maxaf
       from __ap3_&i(where=(__varsrc="s" and __cnt > &tolflag2))
       ;
    quit;

    data _null_;
      call symput("Min", left(put(min(&minbe,&minaf),8.6)));
      call symput("Max", left(put(max(&maxbe,&maxaf),8.6)));
    run;

    data __g;
       if end then do; __min=&min; __max=&max; output; end;
       set __ap3_&i(where=(__varsrc="s" and __cnt > &tolflag2)) End=end;
       output;
    run;

    title4 "Weighted Means Before and After Swapping";
    title5 "KEYOUT=&&keyout&i";
    options nonumber;
    ods &graphtype file="&program_path.&program_prefix._PLOT_MEAN_&program_suffix.&sequence..&graphtype"
    %if &usedpi ne  and %upcase(&graphtype)=PDF %then dpi=&usedpi; ;

    proc sgplot data=__g /*NOAUTOLEGEND*/;
       scatter x=__mbe y=__maf / group=__var;
       vector x=__max y=__max / xorigin=__min yorigin=__min noarrowheads;
       xaxis label="Before Swapping" min=&min max=&max;
       yaxis label="After Swapping" min=&min max=&max;
       label __max="Max" __min="Min" __mbe="Before" __maf="After" __var="Swapvars";
       footnote1 "Symbols were shown only if cell sample sizes exceed &tolflag2";
       footnote2 j=right "&program_path.&program_prefix._PLOT_MEAN_&program_suffix.&sequence..&graphtype";
    run;
    footnote1;
    options number LineSize=&ls;
    quit;

    %end;
    %end;

    ods &graphtype close;
    ods graphics off;
    ods listing;

    title3 "Supplemental Tables for DRB Members";
    %end;
    /*end of plotting */


    proc datasets nolist;
       delete __t1 __ap1 __t2 __ap2 %if &keyout ne %then __t3 __ap3_1-__ap3_&n_keyouts.; __g;
    quit;

    %let flgU=0;
    %let flgW=0;
    %let flgM=0;
    %let flgU2=0;
    %let flgW2=0;
    %let flgM2=0;
    footnote;

   %end;

%end_table02:

%MEND DS_TABLE02;

*****SUBROUTINE PRODUCE DRB CHAIR REPORTS****;
%MACRO DS_TABLE1(var=,print=);

    %if &print= %then %do;
       data __j(keep=__v __p);
          retain __count 0;
          length __v $ 64;
          if eof then do;
             __v = left("&var");
             __p = __count/&nobs*100;
             output;
          end;
          set __swap end=eof;
          ***if &sampflag ne ' ';
          if %unquote(__&var)_change_flag>='1' then __count+1;
       run;

       /***
       proc freq data=__swap;
          tables %unquote(__&&swapvar&i.)_change_flag/noprint
                 out=__j(keep=count);
          where %unquote(__&&swapvar&i.)_change_flag>='1';
       run;

       data __j;
          length __v $ 64;
          set __j;
          __v=left("&&swapvar&i");
       run;
       ***/

       proc append data=__j base=__k;
       run;
    %end;
    %else %do;
       /***
       data __k;
          if eof then do;
             __v="Overall";
             __p = __count/&nobs;
             output;
          end ;
          set __k end=eof;
          __p = __count/&nobs;
          output;
          drop __count;
       run;
       ***/
       proc print data=__k split="#" &showobs;
          label __p="Percent#of Records Changed";
          label __v="Variable";
       run;

       proc datasets nolist;
          delete __k __j;
       quit;
    %end;
%MEND DS_TABLE1;

*****SUBROUTINE PRODUCE Measures of Association****;
%MACRO DS_TABLE2(var=,print=);

   /*construct exclusion statements if BOUNDAR_MD, SWAPVARS_MD, KEYOUT_MD, KEYVARS_MD specified*/
   /*new feature ESSIN 2015*/
   %local exclude_stmt;

   %local MDparam nMDparam ;
   %local i j n nvar aword bword cword aparam aparamval ;
   %local avar avalueset ;

   %let MDparam=BOUNDARY_MD SWAPVARS_MD KEYVARS_MD KEYOUT_MD;                         ;
   %let nMDparam=%sysfunc(countw(&MDparam));

   %do i=1 %to &nMDparam;
      %let aWord=%scan(&MDparam, &i);
      %let bWord=%str(&)%quote(&aWord);
      %let cWord=%unquote(&bWord);
      %let cWord=%sysfunc(TRANWRD(&cWord,%str(##),%str(# #)));

      %let j=%eval(%index(&aword,%str(_))-1);
      %let aparam=%substr(&aword,1,&j);
      %let bWord=%str(&)%quote(&aparam);
      %let aparamval=%unquote(&bWord);

      %if %length(&cword)>0 %then %do;
         %let n=%eval(%sysfunc(countc(&cWord,%str(#)))+1);

         %do j=1 %to &n;
            %let avar=%scan(&aparamval,&j,%str( ));
            %let avalueset=%scan(&cword,&j,%str(#));

            %if %length(&avalueset)>0 %then %do;
               %let exclude_stmt=&exclude_stmt if &avar in (&avalueset) then call missing(&avar) %str(;) ;
            %end;
         %end;
      %end;
   %end;


    %local i j vars_maxlen cntFreq n_vars_real ;
    %local vars_names vars_recode vars_real;
    %local vars_exclude1;  /* N not in [2,16] BOUNDARY */
    %local vars_exclude2;  /* O but char      BOUNDARY */
    %local vars_exclude3;  /* N not in [2,16] SWAPVARS */
    %local vars_exclude4;  /* O but char      SWAPVARS */
    %local vars_exclude5;  /* N not in [2,16] KEYVARS */
    %local vars_exclude6;  /* O but char      KEYVARS */
    %local vars_indep vars_indep_x n_vars_indep;
    %local vars_indep_class;
    %let vars_maxlen=0;
    %let n_vars_real=0;
    %let n_vars_indep=0;
    *;
    ****recode character variables for proc corr****;
    *;
    data _null_;
       if _n_ = 1 then set &holder(keep=&swapcell &linkvars &keyout &keyvars);
      %do i=1 %to &n_cellvar;
       call symput("vfmc&i",left(vtype(&&scell&i)));
      %end;
      %do i=1 %to &n_keyvars;
       call symput("vfmk&i",left(vtype(&&keyvar&i)));
      %end;
      stop;
    run;

    %**** this step is needed if no recode is needed;
    /***
    data __tmp1;
       set &tmpdsn;
    run;
    ***/

    %do i = 1 %to &n_cellvar;
       %if &i <= &n_boundvar %then %do;
          %let k = &i;
          %let vt = &&vtb&k;
       %end;
       %else %do;
          %let k = %eval(&i-&n_boundvar);
          %let vt = &&vts&k;
       %end;

       /* this SWAPVARS has been imputed. Remove the trailing _I from the name */
       %if (&i>&n_boundvar and &&nmiss&k>0 and %upcase(%substr(&impute,1,1))=Y) %then %do;
          %let scell&i=%substr(&&scell&i,1,%length(&&scell&i)-2);
       %end;

       /*add SWAPVARS but not BOUNDARY to vars_analysis*/
       /*changed to include BOUNDAY to vars_analysis 1-29-09*/
       %if %index(%quote(%str( )%upcase(&vars_analysis)%str( )),%quote(%str( )%upcase(&&scell&i)%str( )))=0 %then %do;
          /*%if &i > &n_boundvar %then %do;*/
             %let vars_analysis=&vars_analysis &&scell&i;
             %let n_vars_analysis=%eval(&n_vars_analysis+1);
          /*%end;*/
       %end;

       %if %index(%quote(%str( )%upcase(&vars_real)%str( )),%quote(%str( )%upcase(&&scell&i)%str( )))=0 %then %do;

          %if &vt=N %then %do;
             %BuildIndexVar(indsn1=&holder, indsn2=&tmpdsn,var=&&scell&i, vartype=&&vfmc&i)
             %if &cntFreq>0 %then %do;
                %let vars_recode = &vars_recode &&scell&i.._*;

                %if &cntFreq=2 %then %do;
                   %let vars_real = &vars_real &&scell&i.._1;
                   %let n_vars_real=%eval(&n_vars_real + 1);
                   %let vars_names=&vars_names __nam&n_vars_real "&&scell&i.._1" ;
                   %if %length(&&scell&i.._1) > &vars_maxlen %then %let vars_maxlen=%length(&&scell&i.._1);
                %end;
                %else %do;
                   %let vars_real = &vars_real &&scell&i.._1-&&scell&i.._&cntFreq;

                   %do j=1 %to &cntFreq;
                      %let n_vars_real=%eval(&n_vars_real + 1);
                      %let vars_names=&vars_names __nam&n_vars_real "&&scell&i.._&j" ;
                      %if %length(&&scell&i.._&j) > &vars_maxlen %then %let vars_maxlen=%length(&&scell&i.._&j);
              %end;
           %end;

           /*keep only SWAPVARS, no BOUNDARY for regression models*/
           %if &i > &n_boundvar %then %do;
              %let vars_indep_class=&vars_indep_class &&scell&i;
              %let vars_indep_x=&vars_indep_x &&scell&i.._*;

              /*Tom & Sylvia decided to use original variable names*/
              /*in proc glmmod instead of the recoded 1/26/09*/
              /*
              %do j=1 %to %eval(&cntFreq-1);
                 %let vars_indep=&vars_indep &&scell&i.._&j;
                      %let n_vars_indep=%eval(&n_vars_indep + 1);
              %end;
              */
                   %let vars_indep=&vars_indep &&scell&i;
                   %let n_vars_indep=%eval(&n_vars_indep + 1);
           %end;
        %end;
           %else %if &cntFreq=-99 %then %do; /* N of (0,1) */
                %let vars_real=&vars_real &&scell&i;
                %let n_vars_real=%eval(&n_vars_real + 1);
                %let vars_names=&vars_names __nam&n_vars_real "&&scell&i" ;
                %if %length(&&scell&i) > &vars_maxlen %then %let vars_maxlen=%length(&&scell&i);

                /*include SWAPVARS but not BOUNDARY for regression models*/
           %if &i > &n_boundvar %then %do;
              %let vars_indep_class=&vars_indep_class &&scell&i;
                   %let vars_indep=&vars_indep &&scell&i;
                   %let n_vars_indep=%eval(&n_vars_indep + 1);
           %end;
             %end;
        %else %do;                        /* N not in [2,16] */
           %if &i <= &n_boundvar %then %do;
                 %let vars_exclude1=&vars_exclude1 &&scell&i;
              %end;
              %else %do;
                 %let vars_exclude3=&vars_exclude3 &&scell&i;
              %end;
        %end;
     %end;
     %else %do;
        %if &&vfmc&i=N %then %do;         /* O and Num */
                %let vars_real=&vars_real &&scell&i;
                %let n_vars_real=%eval(&n_vars_real + 1);
                %let vars_names=&vars_names __nam&n_vars_real "&&scell&i" ;
                %if %length(&&scell&i) > &vars_maxlen %then %let vars_maxlen=%length(&&scell&i);

                /*include SWAPVARS but not BOUNDARY for regression models*/
           %if &i > &n_boundvar %then %do;
                   %let vars_indep=&vars_indep &&scell&i;
                   %let n_vars_indep=%eval(&n_vars_indep + 1);
           %end;
        %end;
        %else %do;                        /* O and Char */
           %if &i <= &n_boundvar %then %do;
              %let vars_exclude2=&vars_exclude2 &&scell&i;
           %end;
           %else %do;
              %let vars_exclude4=&vars_exclude4 &&scell&i;
           %end;
        %end;
          %end;
       %end;
    %end;

    %do i = 1 %to &n_keyouts;
       %let keyo=%scan(&keyout,&i);
       %if %index(%quote(%str( )%upcase(&vars_real)%str( )),%quote(%str( )%upcase(&keyo)%str( )))=0 %then %do;
          %let vars_real=&vars_real &keyo;
          %let n_vars_real=%eval(&n_vars_real + 1);
          %if %length(&keyo) > &vars_maxlen %then %let vars_maxlen=%length(&keyo);
          %let vars_names=&vars_names __nam&n_vars_real "&keyo" ;
       %end;
       /*per Tom's request, remove KEYOUTS from Cramers V and Contingency Coefficient computation. 11/11/08*/
       /**
       %if %index(%quote(%str( )%upcase(&vars_analysis)%str( )),%quote(%str( )%upcase(&keyo)%str( )))=0 %then %do;
          %let vars_analysis=&vars_analysis &keyo;
          %let n_vars_analysis=%eval(&n_vars_analysis+1);
       %end;
       **/
    %end;

    %do i = 1 %to &n_keyvars;
       %if %index(%quote(%str( )%upcase(&vars_analysis)%str( )),%quote(%str( )%upcase(&&keyvar&i)%str( )))=0 %then %do;
          %let vars_analysis=&vars_analysis &&keyvar&i;
          %let n_vars_analysis=%eval(&n_vars_analysis+1);
       %end;

       %if %index(%quote(%str( )%upcase(&vars_real)%str( )),%quote(%str( )%upcase(&&keyvar&i)%str( )))=0 %then %do;

          %if &&vtk&i=N %then %do;
             %BuildIndexVar(indsn1=&holder,indsn2=&tmpdsn,var=&&keyvar&i, vartype=&&vfmk&i)
             %if &cntFreq>0 %then %do;
                %let vars_recode = &vars_recode &&keyvar&i.._*;

                %if &cntFreq=2 %then %do;
                   %let vars_real = &vars_real &&keyvar&i.._1;
                   %let n_vars_real=%eval(&n_vars_real + 1);
                   %let vars_names=&vars_names __nam&n_vars_real "&&keyvar&i.._1" ;
                   %if %length(&&keyvar&i.._1) > &vars_maxlen %then %let vars_maxlen=%length(&&keyvar&i.._1);
                %end;
                %else %do;
                   %let vars_real = &vars_real &&keyvar&i.._1-&&keyvar&i.._&cntFreq;

                   %do j=1 %to &cntFreq;
                      %let n_vars_real=%eval(&n_vars_real + 1);
                      %let vars_names=&vars_names __nam&n_vars_real "&&keyvar&i.._&j" ;
                      %if %length(&&keyvar&i.._&j) > &vars_maxlen %then %let vars_maxlen=%length(&&keyvar&i.._&j);
              %end;
           %end;
             %end;
             %else %if &cntFreq=-99 %then %do;
                %let vars_real=&vars_real &&keyvar&i;
                %let n_vars_real=%eval(&n_vars_real + 1);
                %if %length(&&keyvar&i) > &vars_maxlen %then %let vars_maxlen=%length(&&keyvar&i);
                %let vars_names=&vars_names __nam&n_vars_real "&&keyvar&i" ;
             %end;
        %else %do;
           %let vars_exclude5=&vars_exclude5 &&keyvar&i;
        %end;
          %end;
          %else %do;
             %if &&vfmk&i=N %then %do;
                %let vars_real=&vars_real &&keyvar&i;
                %let n_vars_real=%eval(&n_vars_real + 1);
                %if %length(&&keyvar&i) > &vars_maxlen %then %let vars_maxlen=%length(&&keyvar&i);
                %let vars_names=&vars_names __nam&n_vars_real "&&keyvar&i" ;
             %end;
        %else %do;
           %let vars_exclude6=&vars_exclude6 &&keyvar&i;
        %end;
          %end;
       %end;
    %end;

    %if %length(Intercept) > &vars_maxlen %then %let vars_maxlen=%length(Intercept);

    /*recode excluded values to missing if any ###_MD is specified */
    /*new feature ESSIN 2015*/
    %if %length(&exclude_stmt)>0 %then %do;
       data &holder;
          set &holder;
          &exclude_stmt.
       run;
       data &tmpdsn;
          set &tmpdsn;
          &exclude_stmt.
       run;
    %end;

    title4 "Unweighted Measures of Association in Swapping Variables and Key Output Variables";
    title5 "Where r(before)-r(after) is not 0";
    %ds_table22(indsn=&holder, outdsn=__be, outcoef=__beCoef, outN=__beN)
    %ds_table22(indsn=&tmpdsn,  outdsn=__af, outcoef=__afCoef, outN=__afN)
    %ds_table22(print=y,string=Unweighted)

    title4 "Weighted Measures of Association in Swapping Variables and Key Output Variables";
    title5 "Where r(before)-r(after) is not equal to 0";
    %ds_table22(indsn=&holder,outdsn=__be,outcoef=__beCoef,wgt=%str(Weight &wgt;),outN=__beN)
    %ds_table22(indsn=&tmpdsn, outdsn=__af,outcoef=__afCoef,wgt=%str(Weight &wgt;),outN=__afN)
    %ds_table22(print=y,string=Weighted)

    /*set up models for proc reg*/

    /*default models KEYOUT = INTERCEPT SWAPVARS*/
    %if %length(&keyout)>0 %then %do;
       %ds_table3()
    %end;

    /*user defined models*/
    %if &models ne %then %do;
       %ds_table4()
    %end;

%MEND DS_TABLE2;

%MACRO DS_TABLE22(indsn=,outdsn=,outcoef=,outN=,wgt=,string=,print=);
   %local i j k min max;

   %if &print= %then %do;

    proc corr data=&indsn outp=&outdsn noprint;
       &wgt.
       *var &swapcell &swapvars;
       var &vars_real;
       *with &swapvars;
    run;

/***
proc print data=&&outdsn;
title6 "debug after corr : &wgt : &outdsn from &indsn";
run;
title6;
***/

    data &outdsn.;
       length __var1 __var2 $ &vars_maxlen.;
       array __n(&n_vars_real) __n1-__n&n_vars_real;
       array __arr(&n_vars_real) &vars_real;
       array __nam(&n_vars_real) $ &vars_maxlen __nam1-__nam&n_vars_real;
       retain __count 1 &vars_names. __n1-__n&n_vars_real;
       set &outdsn;

       if _type_ = "N" then do;
          do i = 1 to &n_vars_real;
             __n(i)=__arr(i);
          end;
       end;
       else
       if _type_ = "CORR" then do;
          __count+1;

          if index(_name_,"__")=0 then __var1=left(_name_);
          else __var1=substr(_name_,3);
          do i=__count to &n_vars_real;
             __var2=left(__nam(i));
             &outcoef=__arr(i);
             &outN=__n(i);
             output;
          end;
       end;

       keep __var1 __var2 &outcoef &outN;
    run;

/***
proc print data=&&outdsn;
title6 "debug after reset : &wgt : &outdsn from &indsn";
run;
title6;
***/

    proc sort data=&outdsn;
       by __var1 __var2;
    run;
   %end;
   %else %do;
    %let flg=;
    %let n=1;
    data __combined;
       if eof then call symput("sobs",left(put(_n_-1,8.0)));
       merge __be(in=in1)
             __af(in=in2 drop=__afN) end=eof;
       by __var1 __var2;
       if not (in1 and in2) then abort;

       __beCoef_CHAR = put(__beCoef,8.5);

       /*** SE in pseudo code
       SE = (1-CORR^2)/SQRT(N)
       ***/

       if __beN ne 0 then do;
          __beSE = (1-__beCoef**2)/sqrt(__beN);
          __beCI = __beSE*&tolflag3;
       end;

       /***revised 2-22-2008***/
       /***now use tolflag3 in junction with SE ***/
       /***
       if __beCoef ne 0 and abs((__afCoef-__beCoef)/__beCoef) > &tolflag1 and
          abs(__beCoef) > 0.05 then do;
       ***/

       if abs(__afCoef-__beCoef) > __beSE*&tolflag3 then do;
          __afCoef_CHAR = put(__afCoef,8.5)||"*";
          call symput("flg","1");
       end;
       else do;
          __afCoef_CHAR = put(__afCoef,8.5);
       end;
       drop /*__beCoef __afCoef __beSE*/ __beN  __beCI ;

       /***
       label __beCI="(1-Before Coef**2)/#sqrt(Before N) * &tolflag3";
       label __beN="Before#N";
       label __beSE="Before#SE";
       ***/
    run;

    proc print data=__combined split="#" &showobs;
       label __var1="Variable#1";
       label __var2="Variable#2";
       label __beCoef_CHAR="&string#Before Swapping";
       label __afCoef_CHAR="&string#After Swapping";
       var __var1 __var2 __beCoef_CHAR __afCoef_CHAR;
       where __beCoef_CHAR ne __afCoef_CHAR;
       footnote1 "Number of Pairwise Associations computed : &sobs";
       /*print footnote regardless %if &flg=1 %then %do;*/
          %let n=%eval(&n+1);
            /***revised 2-22-2008***/
            /***now use tolflag3 in junction with SE ***/
          /***
          footnote&n "* denotes absolute relative difference exceeds &tolflag1 and correlation before swapping exceeds 0.05";
          ***/
          footnote&n "* denotes the after swapping correlation changed by more than &tolflag3 standard errors";
       /*%end;*/
       %if %length(&vars_recode) > 0 %then %do;
          /***
          %let n=%eval(&n+1);
          footnote&n "Variable(s) '&vars_recode' are indicator variables";
          ***/
          %DS_FNOTES(names=&vars_recode,type=1)
       %end;
       %if %length(%trim(&vars_exclude1 &vars_exclude3 &vars_exclude5)) > 0 %then %do;
          /***
          %let n=%eval(&n+1);
          footnote&n "Variable(s) '%trim(&vars_exclude1 &vars_exclude3 &vars_exclude5)' are excluded because the number of levels is not within [2,&NL]";
          ***/
          %DS_FNOTES(names=&vars_exclude1 &vars_exclude3 &vars_exclude5,type=2)
       %end;
       %if %length(%trim(&vars_exclude2 &vars_exclude4 &vars_exclude6)) > 0 %then %do;
          /***
          %let n=%eval(&n+1);
          footnote&n "Variable(s) '%trim(&vars_exclude2 &vars_exclude4 &vars_exclude6)' are excluded since they are defined as character fields";
          ***/
          %DS_FNOTES(names=&vars_exclude2 &vars_exclude4 &vars_exclude6,type=3)
       %end;
    run;
    footnote1;

   %if &string=Weighted %then %do;

    /* task 1c added August 2011 */
    proc sql noprint;
       select min(__beCoef), max(__beCoef), min(__afCoef), max(__afCoef) into :minbe, :maxbe, :minaf, :maxaf
       from __combined
       ;
    quit;

    data _null_;
      call symput("Min", left(put(min(&minbe,&minaf),8.6)));
      call symput("Max", left(put(max(&maxbe,&maxaf),8.6)));
    run;

    %if %quote(&min) ne %str(.) and %quote(&max) ne %str(.) %then %do;
       data __g;
          if end then do; min=&min; max=&max; output; end;
          set __combined End=end;
          output;
       run;

       ods listing close;
       ods graphics on/border=off;
       options nonumber;
       ods &graphtype file="&program_path.&program_prefix._PLOT_CORR_&program_suffix.&sequence..&graphtype"
       %if &usedpi ne  and %upcase(&graphtype)=PDF %then dpi=&usedpi;;
       Title3 "Graphs for DRB Members";
       Title4 "Weighted Measures of Association Before and After Swapping";

       proc sgplot data=__g  NOAUTOLEGEND;
          scatter x=__beCoef y=__afCoef ;
          vector x=max y=max / xorigin=min yorigin=min noarrowheads;
          xaxis label="Before Swapping" min=&min max=&max;
          yaxis label="After Swapping" min=&min max=&max;
          label /*__max="Max" __min="Min"*/ __beCoef="Before" __afCoef="After";
          footnote j=right "&program_path.&program_prefix._PLOT_CORR_&program_suffix.&sequence..&graphtype";
       run;
       quit;

       ods &graphtype close;
       ods graphics off;
       ods listing;
       quit;
       options number LineSize=&ls;
       footnote;
       title3 "Supplemental Tables for DRB Members";
    %end;


    %local swapvarsquote;
    %let i = 1;
    %let word = %scan (&swapvars, &i, %str( ));
    %do %while (%quote(&word) ^=);
       %let swapvarsquote=&swapvarsquote,"&word";
       %let i=%eval(&i+1);
       %let word = %scan (&swapvars, &i, %str( ));
    %end;

    %let swapvarsquote=%substr(%nrbquote(&swapvarsquote),2);

    data __ASED_Corr;
       set __combined;
       where __beCoef ne __afCoef; /*take only the unequal ones*/
       if __Var1 in (&swapvarsquote) and __Var2 in (&swapvarsquote) then
          __include="1";
    run;
   %end;


    proc datasets nolist;
       delete __be __af __combined
    %if %quote(&min) ne %str(.) and %quote(&max) ne %str(.) %then %do;
       __g
    %end;
    ;
    quit;

   %end;
%MEND DS_TABLE22;

%MACRO DS_TABLE3();
   /* proc reg */

   %local n_statements;
   %let n_statements = &n_keyouts;
   %do i = 1 %to &n_keyouts;
      %local mclass&i;
      %let mclass&i=&vars_indep_class;
      %local n_mvars&i thismodel;
      %let n_mvars&i=%eval(1+&n_vars_indep);
      %let thismodel = &&keyout&i &vars_indep;
      %do j = 1 %to &&n_mvars&i;
         %local mvar&i&j;
         %let mvar&i&j=%scan(&thismodel,&j);
      %end;
   %end;

   %ds_table44(title=Unweighted,p=D)

   %ds_table44(title=Weighted,weight=WEIGHT &wgt %str(;),p=D)


   /*** old method
   %local namearray n i n_indep indep_vars;
   %let n_indep=%eval(1 + &n_vars_indep + 1);
   %let indep_vars= Intercept &vars_indep _RSQ_;

   %do i=1 %to %eval(&n_indep-1);
      %let namearray=&namearray __nam&i "%scan(&indep_vars,&i)" ;
   %end;
   %let namearray=&namearray __nam&n_indep "R-squared" ;

   %ds_table33(title=Unweighted)
   %ds_table33(title=Weighted,weight=WEIGHT &wgt %str(;))
   ***/

%MEND DS_TABLE3;

%MACRO DS_TABLE33(title=,weight=);

   %let n=0;
   %ds_table333(indsn=&holder,outdsn=__be,stage=1,weight=&weight)
   %ds_table333(indsn=&tmpdsn, outdsn=__af,stage=2,weight=&weight)

   data __combined;
      merge __be(in=in1) __af(in=in2);
      by _DEPVAR_ __ord __indep;
      if not (in1 and in2) then do;
         abort;
      end;

      if not first._DEPVAR_ then do;
         _DEPVAR_="";
      end;

      keep _DEPVAR_ __indep __be __af;
   run;

   title4 "&title Multiple Regression Coefficients for model KEYOUT = INTERCEPT SWAPVARS";
   proc print data=__combined split="#" noobs;
      var _DEPVAR_ __indep __be __af;
      label _Depvar_= "Dependent#Variable"
            __indep ="Parameter"
            __be="Estimate#Before#Swapping"
            __af="Estimate#After#Swapping";
      %if %length(&vars_indep_x) > 0 %then %do;
         /***
         %let n=1;
         footnote&n "Variable(s) '&vars_indep_x' are indicator variables";
         ***/
         %DS_FNOTES(names=&vars_indep_x,type=1)
      %end;
      %if %length(&vars_exclude3) > 0 %then %do;
         /***
         %let n=%eval(&n+1);
         footnote&n "Variable(s) '&vars_exclude3' are excluded because the number of levels is not within [2,&NL]";
         ***/
         %DS_FNOTES(names=&vars_exclude3,type=2)
      %end;
      %if %length(&vars_exclude4) > 0 %then %do;
         /***
         %let n=%eval(&n+1);
         footnote&n "Variable(s) '&vars_exclude4' are excluded since they are defined as character fields";
         ***/
         %DS_FNOTES(names=&vars_exclude4,type=3)
      %end;
   run;

  %if &title=Weighted %then %do;
   data __ASED_Reg;
      set __combined;
   run;
  %end;

   proc datasets nolist;
      delete __combined  __af __be;
   quit;

%MEND DS_TABLE33;

%MACRO DS_TABLE333(indsn=,outdsn=,stage=,weight=,print=);
   %local i model;

   %if &print= %then %do;

      %if %upcase(%substr(&corrpred,1,1))=Y %then %do;
         %do i=1 %to &n_keyouts;
          proc reg data=&indsn outest=&outdsn.&i(drop=&&keyout&i) noprint;
             &weight.
             model &&keyout&i.=&vars_indep /rsquare;
             output out=&predsn.&i(keep=&id &predsn.&i) p=&predsn.&i;
          run;
          quit;

          proc append data=&outdsn.&i base=&outdsn;
          run;
         %end;
      %end;
      %else %do;
         /***
         %do i=1 %to &n_keyouts;
            %let model=&model MODEL&i: model &&keyout&i = &vars_indep./rsquare %str(;);
         %end;
         proc reg data=&indsn outest=&outdsn noprint;
            &weight.
            &model.
         run;
         quit;
         ***/

         %do i=1 %to &n_keyouts;
         proc reg data=&indsn outest=__xx noprint;
            &weight.
            MODEL&i: model &&keyout&i = &vars_indep./rsquare ;
         run;
         quit;
         proc print data=__xx;
            title6 "debug __xx";
         run;
         proc append base=&outdsn data=__xx force;
         run;
         %end;

      %end;

   ***proc print data=&outdsn;
   ***   title6 "debug &outdsn";
   ***run;


      /*transpose the proc reg output*/
      data &outdsn;
         set &outdsn(keep=_DEPVAR_ &indep_vars);
         array __x(&n_indep) &indep_vars;
         array __nam(&n_indep) $ &vars_maxlen __nam1-__nam&n_indep;
         retain &namearray. __ord 0;

         do i = 1 to &n_indep;
            __ord=__ord+1;
            &outdsn=__x(i);
            __indep=__nam(i);
            output;
         end;

         keep _DEPVAR_ __indep &outdsn __ord ;
      run;

      proc sort data=&outdsn;
         by  _DEPVAR_ __ord __indep;
      run;
   %end;
%MEND DS_TABLE333;

%MACRO DS_TABLE4();
   %local n_statements;
   %let n_statements = &n_models;
   %do i = 1 %to &n_models;
      %local mclass&i;
      %let mclass&i=&&modelclass&i;
      %local n_mvars&i;
      %let n_mvars&i=&&n_modelvars&i;
      %do j = 1 %to &&n_modelvars&i;
         %local mvar&i&j;
         %let mvar&i&j=&&modelvar&i&j;
      %end;
   %end;

   %ds_table44(title=Unweighted,p=U)

   %ds_table44(title=Weighted,weight=WEIGHT &wgt %str(;),p=U)

%MEND DS_TABLE4;

%MACRO DS_TABLE44(title=,weight=,p=);
   %local flgOutlier flgExclude;
   %let n=0;

   %local i parmN;

   %do i = 1 %to &n_statements;

      %ds_table444(indsn=&holder,outdsn=__be,i=&i,stage=1,weight=&weight)
      %ds_table444(indsn=&tmpdsn, outdsn=__af,i=&i,stage=2,weight=&weight)
      /***%put 2 parmN=&parmN;***/

      *proc print data=__be;
      *   title6 "debug __be";
      *proc print data=__beSE;
      *   title6 "debug __beSE";
      *proc print data=__af;
      *   title6 "debug __af";
      *run;

      data __be_af;
         merge __be   (rename=(parm1=__be))
               __beSE (rename=(seb1=__beSE))
               __af   (rename=(parm1=__af))
               ;
         ***by _MODEL_ _DEPVAR_;

         /**since merging without a by  **/
         /**make sure NAMEs and LABELs  **/
         /**are the same                **/

         if __NAME11 not in ("_EDF_","_RSQ_") then do;
            if __NAME11 NE __NAME12 OR __LABEL11 NE __LABEL12 then do;
               put "11 ne 12 : " _All_;
               abort;
            end;
            if __NAME11 NE __NAME21 OR __LABEL11 NE __LABEL21 then do;
               put "11 ne 21 : " _All_;
               abort;
            end;

            /*Tom said to drop rows that have missing SE*/
            /*2-22-2008*/
            if missing(__beSE) then do;
               call symput("flgExclude","1");
               delete;
            end;
         end;

         __bec = put(__be,8.4);
         if __beSE > 0 and abs((__af-__be)/__beSE) > &tolflag3
            /*and abs(__cbe) > 0.05 */then do;
            __afc = put(__af,8.4)||"*";
            call symput("flgOutlier","1");
         end;
         else do;
            __afc = put(__af,8.4)||" ";
         end;

         /** set up order number if weighted **/
         %if &title=Weighted %then %do;
         __ord = _MODEL_;
         length __lbl $ 60;
          %if &p=D %then %do;
           __lbl = "&&keyout&i=&saveSWAPVARS.";
          %end;
          %else %if &p=U %then %do;
           __lbl = tranwrd("&&model&i",":","=");
           __lbl = tranwrd(__lbl," = ","=");
          %end;
          if length(__lbl)>57 then do;
           __lbl=substr(__lbl,1,57)||"...";
          end;
         %end;

         /** set up block header **/
         if _N_ NE 1 then do;
            _MODEL_="";
            _DEPVAR_="";
         end;

         drop __NAME12 __LABEL12 __NAME21 __LABEL21;
         rename __NAME11=_NAME_ __LABEL11=_LABEL_;
      run;

      ****proc print data=__be_af;
      ****   title6 "debug &&model&i __be_af";
      ****run;

      proc append base=__combined data=__be_af;
      run;

   %end;

   %if &title=Weighted %then %do;
    %if &p=U %then %do;
    data __ASED_Reg_User;
    %end;
    %else %if &p=D %then %do;
    data __ASED_Reg_Default;
    %end;
       set __combined;
    run;
   %end;

   %if &p=U %then %let pile=User-specified Models;
   %else %if &p=D %then %let pile=model KEYOUT = INTERCEPT SWAPVARS;

   title4 "&title Multiple Regression Coefficients for &pile";
   proc print data=__combined split="#" noobs;
      var _DEPVAR_ _LABEL_ __bec __afc;
      label _DEPVAR_= "Dependent#Variable"
            _LABEL_= "Parameter"
            __bec = "Estimate#Before#Swapping"
            __afc =  "Estimate#After#Swapping"
            ;
     %if &p=D %then %do;
      %if %length(&vars_indep_x) > 0 %then %do;
         /*** no indicators involved
         footnote&n "Variable(s) '&vars_indep_x' are indicator variables";
         %DS_FNOTES(names=&vars_indep_x,type=1)
         ***/
      %end;
      %if %length(&vars_exclude3) > 0 %then %do;
         %let n=1;
         /***
         %let n=%eval(&n+1);
         footnote&n "Variable(s) '&vars_exclude3' are excluded because the number of levels is not within [2,&NL]";
         ***/
         %DS_FNOTES(names=&vars_exclude3,type=2)
      %end;
      %if %length(&vars_exclude4) > 0 %then %do;
         /***
         %let n=%eval(&n+1);
         footnote&n "Variable(s) '&vars_exclude4' are excluded since they are defined as character fields";
         ***/
         %DS_FNOTES(names=&vars_exclude4,type=3)
      %end;
     %end;

      /*print footnote regardles %if &flgOutlier=1 %then %do;*/
      %let n=%eval(&n+1);
      footnote&n "* denotes the after swapping beta coefficient changed by more than &tolflag3 standard errors";
      /*%end;*/
      /***removed 4/2/08 per Tom's request***/
      /***
      %if &flgExclude=1 %then %do;
      %let n=%eval(&n+1);
      footnote&n  "Only betas with non-missing SE are shown";
      %end;
      ***/

  run;

   proc datasets nolist;
      delete __design __parm __reg __be __beSE __af __be_af __combined;
   quit;

%MEND DS_TABLE44;

%MACRO DS_TABLE444(indsn=,outdsn=,i=,stage=,weight=);
   %local stage renameCOL parmN&stage;

      proc glmmod data=&indsn outparm=__parm outdesign=__design noprint;
         &weight.
         class &&mclass&i;
         model &&mvar&i.1 =
         %do j=2 %to &&n_mvars&i;
            &&mvar&i&j
         %end;
         %str(;)
      run;

      proc sql noprint;
         select left(put(max(_COLNUM_),8.0)) into :parmN&stage
         from __parm;
      quit;
      /***%put parmN&stage=&&parmN&stage;***/

      %if &stage=1 %then %do;
         %let parmN=&parmN1;
      %end;
      %if &stage=2 %then %do;
         %if &parmN2 ne &parmN %then %do;
            %let err1=&prgname Error: Variable &&mvar&i.1 has different number of levels;
            %let err2=&prgname Error: before and after swapping.;
            %let nerr=2;
            %ds_prnerror(exit=1);

            %let parmN=&parmN2;
         %end;
      %end;

      /***%put parmN=&parmN;***/

      %let renameCOL=;
      %do j=1 %to &parmN;
          %let renameCOL=&renameCOL Col&j=Seb&j;
      %end;

      proc reg data=__design outest=__reg outseb noprint;
         &weight.
         MODEL&i: model &&mvar&i.1 = col1-col&parmN/rsquare;
      run;
      quit;

      proc transpose data=__reg(where=(_TYPE_="PARMS"))
         out=&outdsn PREFIX=PARM NAME=__NAME&stage.1 LABEL=__LABEL&stage.1;
         by _MODEL_ _DEPVAR_;
         var _EDF_ Intercept %if &parmN>1 %then %do; col2-col&parmN %end; _RSQ_ ;
      run;

      /***
      proc print data=&outdsn;
        title4 "&outdsn";
      run;
      ***/

      %if &stage=1 %then %do;
         proc transpose data=__reg(where=(_TYPE_="SEB"))
            out=&outdsn.SE PREFIX=SEB NAME=__NAME12 LABEL=__LABEL12;
            by _MODEL_ _DEPVAR_;
            var _EDF_ Intercept %if &parmN>1 %then %do; col2-col&parmN %end; _RSQ_;
         run;

         /***
         proc print data=&outdsn.SE;
           title4 "&outdsn.SE";
         run;
         ***/
      %end;

%MEND DS_TABLE444;

%MACRO DS_MEASURE();
   %local needfootnote i;
   %local nPairs lstVar1 lstVar2;

   /*Data Utility Measure for Tables - Hellinger's Distance*/

   /*HD application 1*/
   %ds_oneHD(varlist=&swapvars,app=1,HD=HD_AllCells_n)

   /*HD application 2*/
   %ds_oneHD(varlist=&swapvars,app=2,HD=HD_AllCells_n)

   /*HD application 3*/
   %do i = 1 %to &n_swapvars;
      %ds_oneHD(varlist=&&swapvar&i,app=3,HD=HD_&&swapvar&i)
   %end;

   /*HD application 4*/
   %do i = 1 %to &n_swapvars;
      %ds_oneHD(varlist=&&swapvar&i,app=4,HD=HD_&&swapvar&i)
   %end;

   proc print data=__HD split='#' noobs;
      title4 "Data Utility Measure for Tables";
      title5 "SWAPVARS=&SWAPVARS";
      var myName /*myType*/ myTag myHD_CHAR myNumCell;
      label myName="Application"
            /*myType="Type"*/
            myTag="For#Variable(s)"
            myHD_CHAR="Utility value"
            myNumCell="Cell Count/#Small Cell"
            ;
     %if &needfootnote=1 %then %do;
      FOOTNOTE "! denotes small cell(s)";
     %end;
   run;
   footnote;

   /* Data Utility Measure for Correlation Coefficients */

   %if &n_vars_analysis > 1 %then %do;
      %local C_ARD V_ARD;
      %local u l;
      %let u=%eval(&n_vars_analysis-1);
      %do i=1 %to &u;
         %let l=%eval(&i+1);
         %do j=&l %to &n_vars_analysis;
            %let lstVar1=&lstVar1 %scan(&vars_analysis,&i,%str( ));
            %let lstVar2=&lstVar2 %scan(&vars_analysis,&j,%str( ));
            %let nPairs=%eval(&nPairs+1);
         %end;
      %end;

      %ds_oneCHISQmeasure(indsn=&holder,outdsn=__be,suffix=be)
      %ds_oneCHISQmeasure(indsn=&tmpdsn,outdsn=__af,suffix=af)
      %ds_oneCHISQmeasure(combine=y)

      proc sql noprint;
         select count(*) into :N_Prime
         from __ASED_Corr;

         create table __ASED2 as
         select "Pearson's Product Correlation    " as myName,
                sum(abs(__beCoef-__afCoef)/__beSE)/&N_Prime as myASEDvalue
         from __ASED_Corr;

         insert into __ASED2
         values("Pearson's Contingency Coefficient",&C_ARD);

         insert into __ASED2
         values("Cramer's V",&V_ARD);
      quit;

      proc print data=__ASED2 split='#' noobs;
         title4 "Data Utility Measure for Pairwise Associations";
         title5 "Including BOUNDARY, SWAPVARS and KEYVARS";
         label myName="Application"
               myASEDvalue="Utility value"
               ;
      run;
   %end;

   /* Data Utility Measure for Regression Coefficients - all models*/

   ***proc print data=__ASED_Reg_Default;
   ***   title4 "Data Utility Measure for Regression Coefficients";
   ***   title5 "debug __ASED_Reg_Default";
   ***run;

  %if &n_keyouts>0 or &n_models>0 %then %do;

   proc sql noprint;
     %if &n_keyouts>0 %then %do;
      select count(*) into :K_j
      from __ASED_Reg_Default;

      create table __ASED3 as
      select __ord as myOrder,
             __lbl as myName,
             sum(abs(__be-__af)/__beSE)/&K_j as myASEDvalue
      from __ASED_Reg_Default
      group by __ord, __lbl;
     %end;

     %if &n_models>0 %then %do;
      select count(*) into :K_j
      from __ASED_Reg_User;

     %if &n_keyouts>0 %then %do;
      insert into __ASED3
     %end;
     %else %do;
      create table __ASED3 as
     %end;
      select __ord as myOrder,
             __lbl as myName,
             sum(abs(__be-__af)/__beSE)/&K_j as myASEDvalue
      from __ASED_Reg_User
      group by __ord, __lbl;
     %end;

      select sum(myASEDvalue)/count(*) into :ASED_REG
      from __ASED3;

      insert into __ASED3
      values("9999","Across All Regression Models",&ASED_REG);
   quit;

   proc print data=__ASED3 split='#' noobs;
      title4 "Data Utility Measure for Regression Coefficients - Default and User-defined models";
      title5 "KEYOUT=&KEYOUT";
      title6 "SWAPVARS=&SWAPVARS";
      var myName myASEDvalue;
      label myName="Model"
            myASEDvalue="Utility value"
            ;
   run;

  %end;

%mend ds_measure;

%macro ds_oneHD(varlist=,app=,HD=);

   %ds_oneHDmeasure(indsn=&holder,outdsn=__be,suffix=be,varlist=&varlist)
   %ds_oneHDmeasure(indsn=&tmpdsn,outdsn=__af,suffix=af,varlist=&varlist)

   /*added myNumCell*/
   /*new feature ESSIN 2015*/

   data __combined __oneHD(keep=myName /*myType*/ myTag myHD_CHAR myNumCell );
      retain __smallflag ' ' __NumCell __NumSmallCell 0;
      length myTag $ 32 /*myType $ 40*/ myName $ 43 myNumCell $ 7 __NumCell __NumSmallCell 3;
      if eof then do;
         if __smallflag='!' then call symput("needfootnote",'1');
         /*call symput("HD_AllCells_n",LEFT(PUT(sqrt(__cumSUM)/sqrt(2),32.)));*/
         /*myType="&sApplication";*/
        %if &app=1 %then %do;
         myName="Hellinger's Distance, all cells";
         myTag="Across All";
        %end;
        %else %if &app=2 %then %do;
         myName="Hellinger's Distance, excluding small cells";
         myTag="Across All";
        %end;
        %else %if &app=3 %then %do;
         myName="Hellinger's Distance, all cells";
         myTag="&varlist";
        %end;
        %else %if &app=4 %then %do;
         myName="Hellinger's Distance, excluding small cells";
         myTag="&varlist";
        %end;
         myHD=sqrt(__cumSUM)/sqrt(2);
         myHD_CHAR=put(myHD,8.6)||__smallflag;
         myNumCell=cats(right(put(__NumCell,3.0)),"/",left(put(__NumSmallCell,3.0)));

         output __oneHD;

      end;
      merge __BE(in=in1) __AF(in=in2) end=eof;
      by &varlist;
      if not (in1 and in2) then abort;

     %if &app=2 or &app=4 %then %do;
      if N_be > &tolflag2;
     %end;
     %else %do;  /* &app=1 or &app=3 */
      if N_be < &tolflag2 then do;
         __smallflag="!";
      end;
     %end;

      __cumSUM+(sqrt(SumWgt_be)-sqrt(SumWgt_af))**2;

      __NumCell+1;
      if N_be <= &tolflag2 then do;
         __NumSmallCell+1;
      end;

      x1=sqrt(SumWgt_be);
      x2=sqrt(SumWgt_af);
      diff=x1-x2;
      diff2=diff**2;

      /*debug stuff. show any change*/
      /*
      if N_af ne N_be or SumWgt_af ne SumWgt_be then flag="*";
      else flag=" ";
      */

      output __combined;

   run;

   proc append data=__oneHD base=__HD;
   run;
%MEND DS_oneHD;

%macro ds_oneHDmeasure(indsn=,outdsn=,suffix=,varlist=);
   data _null_;
      call symput("varlistcomma",translate("&varlist", ',', ' '));
   run;

   proc sql;
      create table &outdsn as
      select &varlistcomma, count(*) as N_&suffix, sum(&wgt) as SumWgt_&suffix
      from &indsn
      group by &varlistcomma;
   quit;

%mend ds_oneHDmeasure;

%macro ds_oneCHISQmeasure(indsn=,outdsn=,suffix=,combine=);
   %if &nerr ne 0 %then %goto End_oneCHISQmeasure;

   %if &combine=y %then %do;
      %if &debug=1 %then %do;
      data __combined;
      %end;
      %else %do;
      data _null_;
      %end;

         if eof then do;
            if __non0CONTGY ne 0 then do;
               __avgCONTGY=__sumCONTGY/__non0CONTGY;
            end;
            if __non0CRAMV ne 0 then do;
               __avgCRAMV=__sumCRAMV/__non0CRAMV;
            end;

            call symput("C_ARD",left(put(__avgCONTGY,8.6)));
            call symput("V_ARD",left(put(__avgCRAMV,8.6)));
         end;

         merge __be __af END=EOF;
         by __ord;

         if not(__beCONTGY=. or __afCONTGY=. or __beCONTGY=0) then
            __diffCONTGY=abs((__beCONTGY-__afCONTGY)/__beCONTGY);
         if not(__beCRAMV=. or __afCRAMV=. or __beCRAMV=0) then
            __diffCRAMV =abs((__beCRAMV-__afCRAMV)/__beCRAMV);

         if __diffCONTGY ne 0 and __diffCONTGY ne . then do;
            __non0CONTGY+1;
            __sumCONTGY+__diffCONTGY;
         end;
         if __diffCRAMV ne 0 and __diffCRAMV ne . then do;
            __non0CRAMV+1;
            __sumCRAMV+__diffCRAMV;
         end;
      run;

      %if &debug=1 %then %do;
      proc print data=__combined;
         title6 "debug __combined";
         var __ord __beCRAMV __afCRAMV __diffCRAMV;
      run;
      %end;
   %end;
   %else %do;
      %local nchk1 nchk2;
      %do i = 1 %to &nPairs;
         /***%put var1&i=%scan(&lstVar1,&i,%str( ));***/
         /***%put var2&i=%scan(&lstVar2,&i,%str( ));***/
         /*
         proc sql noprint;
            select count(distinct %scan(&lstVar1,&i,%str( ))) into :nchk1
            from &indsn
            where %scan(&lstVar1,&i,%str( )) is not null
            ;
            select count(distinct %scan(&lstVar2,&i,%str( ))) into :nchk2
            from &indsn
            where %scan(&lstVar2,&i,%str( )) is not null
            ;
         quit;
         %if &nchk1<=1 or &nchk2<=1 %then %do;
            %let nchk1=&nchk1;
            %let nchk2=&nchk2;
            %let err1=&prgname Warning: Variables %scan(&lstVar1,&i,%str( )) and %scan(&lstVar2,&i,%str( )) must have at least two nonmissing levels.;
            %let err2=&prgname Warning: Variable %scan(&lstVar1,&i,%str( )) has &nchk1. level(s).;
            %let err3=&prgname Warning: Variable %scan(&lstVar2,&i,%str( )) has &nchk2. level(s).;
            %let err4=&prgname Warning: Pearson%str(%')s Product Correlation and Cramer%str(%')s V will not be computed.;
            %let nerr=4;
            %let C_ARD=.;
            %let V_ARD=.;
            %ds_prnerror(exit=0);
            %goto End_oneCHISQmeasure;
         %end;
         */
         Proc Freq data=&indsn noprint;
            tables %scan(&lstVar1,&i,%str( ))*%scan(&lstVar2,&i,%str( ))/chisq;
            weight &wgt;
            output CONTGY CRAMV out=__oneCHISQ;
         run;

        %if &debug=1 %then %do;
         data __oneCHISQ;
            length var1 var2 $ 32;
            set __oneCHISQ;
            var1="%scan(&lstVar1,&i,%str( ))";
            var2="%scan(&lstVar2,&i,%str( ))";
         run;
         proc print data=__oneCHISQ;
         title6 "debug __oneCHISQ : %scan(&lstVar1,&i,%str( )) by %scan(&lstVar2,&i,%str( ))";
         run;
        %end;

         proc sql noprint;
            %if &i=1 %then %do;
               create table &outdsn. as
                  select &i as __ord,
                  _CONTGY_ as __&suffix.CONTGY ,
                  _CRAMV_ as __&suffix.CRAMV
                  from __oneCHISQ;
            %end;
            %else %do;
               insert into &outdsn.
                  select &i as __ord,
                  _CONTGY_ as __&suffix.CONTGY,
                  _CRAMV_ as __&suffix.CRAMV
                  from __oneCHISQ;
            %end;
         quit;

         /***
         data &outdsn;
            set
           %if &i ne 1 %then %do;
            &outdsn(in=in1)
           %end;
            __onechisq(in=in2);
            if in2 then __ord=&i;
         run;
         ***/
         /***
         proc append data=__onechisq base=&outdsn;
         run;
         ***/
      %end;

     %if &debug=1 %then %do;
      proc print data=&outdsn;
      title6 "debug CHISQ &outdsn";
      run;
     %end;
   %end;

%End_oneCHISQmeasure:

%mend ds_oneCHISQmeasure;

%MACRO BuildIndexVar(INDSN1=,INDSN2=,VAR=,VARTYPE=);
   %local i j stage1 stage2 list;

   proc sql noprint;
      select count(distinct &var) into :cntFreq
      from &indsn1
      where &var is not null;
   quit;
   %let cntFreq=%trim(&cntFreq);

   %if &cntFreq=1 or &cntFreq>&NL %then %do;
      %let cntFreq=0;
      %goto exit_buildindexvar;
   %end;

   proc sql noprint;
      select distinct &var into :val1 - :val&cntFreq
      from &indsn1
      where &var is not null;
   quit;

   /*do not recode if x=0 or 1. use as is (treated as O) */
   %if &cntFreq=2 and (%quote(&val1)=0 and %quote(&val2)=1) %then %do;
      %let cntFreq=-99;
      %goto exit_buildindexvar;
   %end;

   /***%let cntFreq=%eval(&cntFreq - 1);***/
   /***changed to K levels in 8-27-2008***/
   %let stage1=Before;
   %let stage2=After;

   %do i=1 %to &cntFreq;
      %let list=&list * &var._&i;
   %end;

   /*%put***&var recoded***;*/

   %do j=1 %to 2;

   data &&indsn&j;
      set &&indsn&j;

      %do i=1 %to &cntFreq;
         &var._&i=0;
      %end;

      %do i=1 %to &cntFreq;
        %if &i > 1 %then %do;
           else
        %end;
        %if &vartype=C %then %do;
           if trim(left(&var))="&&val&i" then &var._&i=1;
        %end;
        %else %do;
           if &var=&&val&i then &var._&i=1;
        %end;
      %end;

      if missing(&var) then do;
      %do i=1 %to &cntFreq;
         &var._&i=.;
      %end;
      end;
   run;

   %if &j=2 %then %do;
   proc freq data=&&indsn&j;
      title4 "&&stage&j swapping" /*: dataset &&indsn&j*/;
      title5 "Check creation of indicator variables for &var";
      /*tables &var * (&var._1 - &var._&cntFreq)/missing list*/;
      tables &var &list/missing list;
   run;
   %end;
   %end;

%exit_buildindexvar:
%MEND;

*****SUBROUTINE COUNTS VARLIST****;
%MACRO DS_WORDS(STRING=, DELIM=);
   %LOCAL WORD N_COUNT;
   %LET N_COUNT=1;
   %LET N_VAR=1;
   %LET WORD=%NRBQUOTE(%SCAN(&STRING,&N_VAR,&DELIM));
   %DO %WHILE(&WORD NE );
      %IF %UPCASE('&WORD') NE 'DESCENDING' AND
          %UPCASE('&WORD') NE 'ASCENDING' %THEN %DO;
          %LET CELL&N_VAR=&WORD.;
          %LET N_VAR=%EVAL(&N_VAR+1);
      %END;
      %LET N_COUNT=%EVAL(&N_COUNT+1);
      %LET WORD=%NRBQUOTE(%SCAN(&STRING,&N_COUNT,&DELIM));
   %END;
   %LET N_VAR=%EVAL(&N_VAR-1);
%MEND DS_WORDS;

*****SUBROUTINE COUNTS VARLIST****;
%MACRO DS_WORDSXX(STRING=, DELIM=);
   %LOCAL WORD N_COUNT;
   %LET N_COUNT=1;
   %LET N_VAR=1;
   %LET WORD=%NRBQUOTE(%SCAN(&STRING,&N_VAR,&DELIM));
   %DO %WHILE(&WORD NE );
      %IF %UPCASE('&WORD') NE 'DESCENDING' AND
          %UPCASE('&WORD') NE 'ASCENDING' %THEN %DO;
          %LET CELL&N_VAR=&WORD.;
          %LET N_VAR=%EVAL(&N_VAR+1);
      %END;
      %LET N_COUNT=%EVAL(&N_COUNT+1);
      %LET WORD=%NRBQUOTE(%SCAN(&STRING,&N_COUNT,&DELIM));
   %END;
   %LET N_VAR=%EVAL(&N_VAR-1);
%MEND DS_WORDSXX;

*****SUBROUTINE CHECKS ERRORS****;
%MACRO DS_PRNERROR(exit=1);
   %local i slen sline stype;

   %if &exit=1 %then %let stype=Error;
   %else %let stype=Warning;
   %let slen=0;
   %do i = 1 %to &nerr;
       %if %length(&&err&i) > &slen %then %let slen=%length(&&err&i);
   %end;
   %do i = 1 %to &slen;
       %let sline=&sline*;
   %end;
   %put ;
   %put ;
   %put &sline;
   %put &prgname &stype: ;
   %do i = 1 %to &nerr;
   %put &&err&i.;
   %end;

   %if &exit=1 %then %do;
   %put &prgname &stype: Program has aborted.;
   %end;
   %put &prgname &stype: ;
   %put &sline;
   %put ;
   %put ;
%MEND DS_PRNERROR;

*****SUBROUTINE INDENT FOOTNOTES****;
%macro DS_FNOTES(names=,type=);
   %local fulltext s1 s2 text pos1 len taken;
   %let names=%trim(&names);

   %if &type=1 %then %do;        /*indicators*/
      %let s1=Variable(s);
      %let s2=are indicator variables;
   %end;
   %else %if &type=2 %then %do;  /*exclude not in [2,&NL]*/
      %let s1=Variable(s);
      %let s2=are excluded because the number of levels is not within [2,&NL];
   %end;
   %else %if &type=3 %then %do;  /*exclude character*/
      %let s1=Variable(s);
      %let s2=are excluded since they are defined as character fields;
   %end;

   %let fulltext=%nrbquote(&s1 '&names' &s2);
   %let len=%length(&fulltext);

   %if &debug=1 %then %do;
   %put the fulltext is;
   %put &fulltext;
   %put len=&len;
   %end;
   /*%put ls=&ls;*/

   %if &ls<=10 %then %do;
      %let err1=&prgname Warning: Your LS option was set too small to support a sensible footnote.;
      %let err2=&prgname Warning: The footnotes have been deleted.;
      %let nerr=2;
      %ds_prnerror(exit=0);
   %end;
   %else %if &len > &ls %then %do;
      %let pos1=1;
      %do %while(&len > 0);
         %if &ls>&len %then %let taken=&len;
         %else %let taken=&ls;

    %if &debug=1 %then %do;
         %put before trimming pos1=&pos1;
         %put before trimming taken=&taken;
    %end;

         %if %eval(&pos1+&taken-1)<%length(&fulltext) %then %do;
            %do %while (%qsubstr(%nrquote(&fulltext),%eval(&pos1+&taken-1),1) ne %nrstr( ) and
                        %qsubstr(%nrquote(&fulltext),%eval(&pos1+&taken  ),1) ne %nrstr( ));
                %let taken=%eval(&taken-1);

                %if &debug=1 %then %do;
                %put trimming taken=&taken;
                %end;
            %end;
         %end;

         %if &debug=1 %then %do;
         %put after trimming pos1=&pos1;
         %put after trimming taken=&taken;
         %end;

         %let text=%qsubstr(%nrquote(&fulltext),&pos1, &taken);

         %let n=%eval(&n+1);

         %if &n>10 %then %do;
            %let err1=&prgname Warning: Your LineSize option was set too small.;
            %let err2=&prgname Warning: The footnotes have been truncated.;
            %let nerr=2;
            %ds_prnerror(exit=0);
            %let len=0;
         %end;
         %else %do;
            footnote&n "%trim(&text)";
            %let pos1=%eval(&pos1+&taken);
            %let len=%eval(%length(&fulltext)-&pos1+1);
         %end;

         %if &debug=1 %then %do;
         %put next fold pos1=&pos1;
         %put next fold taken=&taken;
         %put next fold len=&len;
         %end;
      %end;
   %end;
   %else %do;
      %let n=%eval(&n+1);
      footnote&n "&s1 '&names' &s2";
   %end;

%mend DS_FNOTES;

*****SUBROUTINE VALIDATES PARAMETERS****;
%MACRO DS_VALIDATE(STRING=);
   %local tmpsort n_sortvars inddvars;

   %let id=%trim(&id);
   %let mos=%trim(&mos);
   %let sortvars=%trim(&sortvars);
   %let stratum=%trim(&stratum);
   %let rate=%trim(&rate);
   %let certflag=%trim(&certflag);

   %if %length(&boundary)>0 %then %let boundary=%sysfunc(compbl(&boundary));
   %if %length(&swapvars)>0 %then %let swapvars=%sysfunc(compbl(&swapvars));
   %if %length(&linkswap)>0 %then %let linkswap=%sysfunc(compbl(&linkswap));
   %let missingvar=%trim(&missingvar);
   %let r_method=%trim(&r_method);
   %let biasvar=%trim(&biasvar);
   %let wgt=%trim(&wgt);

   %if %length(&keyout)>0 %then%let keyout=%sysfunc(compbl(&keyout));
   %if %length(&keyvars)>0 %then %let keyvars=%sysfunc(compbl(&keyvars));
   %let tolflag=%trim(&tolflag);
   %let maxcat=%trim(&maxcat);
   %let listpair=%trim(&listpair);
   %let models=%trim(&models);
   %let modelclass=%trim(&modelclass);

   %let impute=%trim(&impute);
   %let missingdef=%trim(&missingdef);

   **** set default values ****;

   %if %length(&NL)=0 %then %let NL=16;

   %if %length(&seed)= or &seed=0 %then %do;
      data _null_;
         call symput("ActualSeed",TRIM(left(put(ranuni(0)*100000,8.))));
      run;
   %end;
   %else %do;
      %let ActualSeed=&seed;
   %end;

   %let SWAPMETH=%trim(&SWAPMETH);
   %if %length(&SWAPMETH)=0 %then %do;
      %let SWAPMETH=1;
   %end;

   %if %length(&tolflag)=0 %then %do;
       %let tolflag=0.1#45#1.96#1.1;
   %end;
   %if %length(&maxcat)=0 %then %do;
       %let maxcat=20;
   %end;
   %if %length(&listpair)=0 %then %do;
       %let listpair=S#1.0;
   %end;

   %if %length(&impute)=0 %then %do;
       %let impute=y;
   %end;

   %if %length(&corrpred)=0 %then %do;
       %let corrpred=_;
   %end;

   %if %length(&graphtype)=0 %then %do;
       %let graphtype=rtf;
   %end;

   **** check input variables syntax ****;

   %if %length(&rate) = 0 %then
       %let err1=&prgname Error: Parameter RATE is required. ;
   %else
       %if %index(&rate,%str( )) > 0 %then
          %let err1=&prgname Error: Parameter RATE must be a single variable or value.  You have specified &rate..;

   %if %length(&id) = 0 %then
       %let err1=&prgname Error: Parameter ID is required. ;
   %else
       %if %index(&id, %str( )) > 0 %then
          %let err1=&prgname Error: Parameter ID must be a single variable.  You have specified &id..;

   %if %length(&swapvars) = 0 %then %do;
       %let err1=&prgname Error: Parameter SWAPVARS is required. ;
   %end;

   %if %length(&wgt) = 0 %then %do;
       %let err1=&prgname Error: Parameter WGT is required. ;
   %end;

   %if %length(&biasvar) > 0 %then
       %if %index(&biasvar, %str( )) > 0 %then
          %let err1=&prgname Error: Parameter BIASVAR must be a single variable.  You have specified &biasvar..;

   %if %length(&wgt) > 0 %then
       %if %index(&wgt, %str( )) > 0 %then
          %let err1=&prgname Error: Parameter WGT must be a single variable.  You have specified &wgt..;

   %if %length(&mos) > 0 %then
       %if %index(&mos, %str( )) > 0 %then
          %let err1=&prgname Error: Parameter MOS must be a single variable/value.  You have specified &mos..;

   %if %length(&certflag) > 0 %then
       %if %index(&certflag, %str( )) > 0 %then
          %let err1=&prgname Error: Parameter CERTFLAG must be a single variable.  You have specified &certflag..;

   %if %length(&stratum) > 0 %then
       %if %index(&stratum, %str( )) > 0 %then
          %let err1=&prgname Error: Parameter STRATUM must be a single variable.  You have specified &stratum..;

   %if %length(&err1) > 1 %then %goto endvalidate;

   %if not (&SWAPMETH=1 or &SWAPMETH=2) %then %do;
       %let err1=&prgname Error: Parameter SWAPMETH can only be 1 or 2.;
       %let err2=&prgname Error: You have specified &SWAPMETH..;
       %let nerr=2;
   %end;

   ****verify ID ****;
   %ds_chkparam(type=id,var=&id)

   ****parse SORTVARS****;
   %local tmpsort;
   %if %length(&sortvars)>0 %then %do;
      %ds_words(string=&sortvars,delim=%str( ))

      %let n_sortvars=&n_var;
      %let tmpsort=;
      %do i=1 %to &n_sortvars;
          %let tmpsort=&tmpsort %unquote(&&cell&i.);

          %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(%unquote(&&cell&i.))%str( )))=0 %then %do;
              %let invars=&invars %unquote(&&cell&i.);
          %end;
     %end;
/***%put tmpsort=&tmpsort;***/
   %end;

   ****parse BOUNDARY****;
   %if %length(&boundary)>0 %then %do;
       %ds_words(string=&boundary,delim=%str( ))

       %let n_boundvar=&n_var;

       %if &n_boundvar>&nlimit %then %do;
           %let err1=&prgname Error: The maximum number of variables allowed in BOUNDARY is &nlimit..;
           %let err2=&prgname Error: You have specified &n_boundvar..;
           %let nerr=2;
       %end;

       %let boundary=;
       %do i=1 %to &n_boundvar;
          %let boundary=&boundary &&cell&i.;

          %if %index(%quote(%str( )%upcase(&swapvars)%str( )),%quote(%str( )%upcase(&&cell&i)%str( )))>0 %then %do;
             %let err1=&prgname Error: Variable used in BOUNDARY can not be used in SWAPVARS.;
             %let err2=&prgname Error: You have specified BOUNDARY=&boundary. and SWAPVARS=&swapvars..;
             %let nerr=2;
          %end;

          %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(%unquote(&&cell&i.))%str( )))=0 %then %do;
             %let invars=&invars %unquote(&&cell&i.);
          %end;
       %end;
       %let first_boundary=%unquote(&cell1);
       %let last_boundary=%unquote(&&cell&n_boundvar);

   %end;
   %else %let n_boundvar=0;

   ****parse BOUNDARY_T****;
   %if &n_boundvar > 0 %then %do;
       %if %length(&boundary_t)=0 %then %do;
          %do i=1 %to &n_boundvar;
             %let vtb&i=O;
             %let boundary_t = &boundary_t O;
          %end;
          %let boundary_t=&boundary_t (Default);
       %end;
       %else %do;
          %ds_words(string=&boundary_t,delim=%str( ))
          %if &n_var ne &n_boundvar %then %do;
             %let err1=&prgname Error: Parameter BOUNDARY_T must have equal number of items as in BOUNDARY.;
             %let err2=&prgname Error: You have specified BOUNDARY=&boundary and BOUNDARY_T=&boundary_t..;
             %let nerr=2;
          %end;
          %else %do;
             %do i = 1 %to &n_boundvar;
                %let vtb&i=%upcase(%scan(&boundary_t,&i));
             %end;
          %end;
       %end;
   %end;
   %else %do;
       %if %length(&boundary_t) > 0 %then %do;
          %let err1=&prgname Error: Parameter BOUNDARY_T must be left blank when BOUNDARY is not used.;
          %let err2=&prgname Error: You have specified BOUNDARY_T=&boundary_t..;
          %let nerr=2;
       %end;
   %end;

   ****parse SWAPVARS****;
   %let n_swapvars=0;

   %ds_words(string=&swapvars,delim=%str( ))
   %let n_swapvars=&n_var;

   %if &n_swapvars>&nlimit %then %do;
       %let err1=&prgname Error: The maximum number of variables allowed in SWAPVARS is &nlimit..;
       %let err2=&prgname Error: You have specified &n_swapvars..;
       %let nerr=2;
   %end;

/***%put swapvars=&swapvars;***/
/***%put n_swapvars=&n_swapvars;***/
/***%put in1 invars=&invars;***/

   %do i=1 %to &n_swapvars;
       %let swapvar&i=%unquote(&&cell&i);

       %if %index(%quote(%str( )%upcase(&keyout)%str( )),%quote(%str( )%upcase(&&cell&i)%str( )))>0 %then %do;
          %let err1=&prgname Error: Variable used in SWAPVARS can not be used in KEYOUT.;
          %let err2=&prgname Error: You have specified SWAPVARS=&swapvars. and KEYOUT=&keyout..;
          %let nerr=2;
       %end;

       %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&&swapvar&i)%str( )))=0 %then %do;
           %let invars=&invars &&swapvar&i;
       %end;
/***%put swapvar&i=&&swapvar&i.;***/
   %end;
/***%put in2 invars=&invars;***/

   %let i=1;
   %let swp_RENAME=%unquote(&&swapvar&i=__o_&&swapvar&i) ;
   %let swp_IF=%unquote(&&swapvar&i=__o_&&swapvar&i) ;
   %let swp_DROP=__o_%unquote(&&swapvar&i) ;
   %do i=2 %to &n_swapvars;
       %let swapv&i=%unquote(&&swapvar&i);
       %let swp_RENAME= &swp_RENAME %unquote(&&swapvar&i=__o_&&swapvar&i) ;
       %let swp_IF    = &swp_IF and %unquote(&&swapvar&i=__o_&&swapvar&i) ;
       %let swp_DROP  = &swp_DROP __o_%unquote(&&swapvar&i) ;
   %end;

   ****parse SWAPVARS_T****;
   %if &n_swapvars > 0 %then %do;
       %if %length(&SWAPVARS_t)=0 %then %do;
          %do i=1 %to &n_swapvars;
             %let vts&i=O;
             %let SWAPVARS_t = &SWAPVARS_t O;
          %end;
          %let swapvars_t=&swapvars_t (Default);
       %end;
       %else %do;
          %ds_words(string=&swapvars_t,delim=%str( ))
          %if &n_var ne &n_swapvars %then %do;
             %let err1=&prgname Error: Parameter SWAPVARS_T must have equal number of items as in SWAPVARS.;
             %let err2=&prgname Error: You have specified SWAPVARS=&SWAPVARS and SWAPVARS_T=&SWAPVARS_t..;
             %let nerr=2;
          %end;
          %else %do;
             %do i = 1 %to &n_swapvars;
                %let vts&i=%upcase(%scan(&SWAPVARS_t,&i));
             %end;
          %end;
       %end;
   %end;
   %else %do;
       %if %length(&SWAPVARS_t) > 0 %then %do;
          %let err1=&prgname Error: Parameter SWAPVARS_T must be left blank when SWAPVARS is not used.;
          %let err2=&prgname Error: You have specified SWAPVARS_T=&SWAPVARS_t..;
          %let nerr=2;
       %end;
   %end;

   ****parse SWAPCELL****;
   %let swapcell=&boundary &swapvars;
   %ds_words(string=&swapcell,delim=%str( ))
   %let n_cellvar=&n_var;

   %let tmpcelldef=&cell1;
   %let swapcell=&cell1;
   %let scell1=%unquote(&cell1);
   %DO I = 2 %TO &n_cellvar;
      /***%PUT CELL&I = &&cell&i; ***/
      %let tmpcelldef=&tmpcelldef.||&&cell&i.;
      %let swapcell=&swapcell &&cell&i.;
      %let scell&i=%unquote(&&cell&i);
   %END;

/***%put swapcell=&swapcell;***/

   ****default BIASVAR****;
   %if %length(&biasvar)=0 %then
       %let b_var=%unquote(&&swapvar&n_swapvars.);
   %else
       %let b_var=&biasvar;

   %if %index(%quote(%str( )%upcase(&swapvars)%str( )),%quote(%str( )%upcase(&b_var)%str( )))=0 %then %do;
       %let err1=&prgname Error: Parameter BIASVAR must be a variable in SWAPVARS.;
       %let err2=&prgname Error: You have specified SWAPVARS=&swapvars and BIASVAR=&biasvar..;
       %let nerr=2;
   %end;
   /*
   %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&b_var)%str( )))=0 %then
       %let invars=&invars &b_var;
   */

   ****parse LINKSWAP****;
   %let n_linkvars=0;
   %let n_linksets=0;
   %if %length(&linkswap) > 0 %then %do;
      %let n_linkvars=0;

      %if %index(&linkswap,#)=1 %then
         %ds_words(string=null&linkswap,delim=%str(#));
      %else
         %ds_words(string=&linkswap,delim=%str(#)) ;

      %let n_linksets=&n_var;

%if &debug=1 %then %do;
%put linkswap=&linkswap;
%put n_linksets=&n_linksets;
%put ;
%end;

      %do i=1 %to &n_linksets;
          %let linkset&i=%unquote(&&cell&i);

          %if %upcase(&&linkset&i)=NULL %then %do;
              %let linkset&i=;
          %end;
      %end;

      %do i=1 %to &n_linksets;
          %ds_words(string=&&linkset&i,delim=%str( ))
          %let n_link&i=&n_var;

%if &debug=1 %then %do;
%put linkset&i=&&linkset&i;
%put n_link&i=&&n_link&i;
%put ;
%end;

          %do j=1 %to &&n_link&i;
              %let n_linkvars=%eval(&n_linkvars+1);
              %let linkvars=&linkvars %unquote(&&cell&j);
              %let linkv&i&j=%unquote(&&cell&j);
              %let linkvar&n_linkvars=%unquote(&&cell&j);

%if &debug=1 %then %do;
%put n_linkvars=&n_linkvars;
%put linkv&i&j=&&linkv&i&j;
%put linkvar&n_linkvars=&&linkvar&n_linkvars;
%put ;
%end;

              %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&&linkv&i&j)%str( )))=0 %then %do;
                  %let invars=&invars &&linkv&i&j;
              %end;
              %else %do;
                  %let err1=&prgname Error: One of your LINKSWAP - &&linkv&i&j has been used twice.;
                  %let err2=&prgname Error: Please check your parameters.;
                  %let nerr=2;
              %end;
          %end;
      %end;

%if &debug=1 %then %do;
%put linkvars=&linkvars;
%put n_linkvars=&n_linkvars;
%put;
%end;

      %do i=1 %to &n_linkvars;
          %let swp_RENAME= &swp_RENAME %unquote(&&linkvar&i=__o_&&linkvar&i) ;
          /***%let swp_IF    = &swp_IF and %unquote(&&linkvar&i=__o_&&linkvar&i) ; ***/
          %let swp_DROP  = &swp_DROP __o_%unquote(&&linkvar&i) ;
      %end;
   %end;

   %if &n_linksets ne 0 and &n_swapvars ne &n_linksets %then %do;
       %let err1=&prgname Error: The number of variables in SWAPVARS does not match the number of sets in LINKSWAP.;
       %let err2=&prgname Error: You have specified SWAPVARS=&swapvars and LINKSWAP=&linkswap..;
       %let nerr=2;
   %end;

   ****parse KEYOUTS****;
   %let n_keyouts=0;

   %ds_words(string=&keyout,delim=%str( ))
   %let n_keyouts=&n_var;
   %do i=1 %to &n_keyouts;
       %global keyout&i;
       %let keyout&i=%unquote(&&cell&i);
       %let myGlobal=&myGlobal keyout&i;

       %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&&keyout&i)%str( )))=0 %then %do;
           %let invars=&invars &&keyout&i;
       %end;
   %end;

   ****parse KEYVARS****;
   %let n_keyvars=0;

   %ds_words(string=&keyvars,delim=%str( ))
   %let n_keyvars=&n_var;
   %do i=1 %to &n_keyvars;
       %global keyvar&i vtk&i;
       %let keyvar&i=%unquote(&&cell&i);
       %let myGlobal=&myGlobal keyvar&i vtk&i;

       %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&&keyvar&i)%str( )))=0 %then %do;
           %let invars=&invars &&keyvar&i;
       %end;
   %end;

   ****parse KEYVARS_T****;
   %if &n_KEYVARS > 0 %then %do;
       %if %length(&KEYVARS_t)=0 %then %do;
          %do i=1 %to &n_KEYVARS;
             %let vtk&i=O;
             %let KEYVARS_t = &KEYVARS_t O;
          %end;
          %let KEYVARS_t=&KEYVARS_t (Default);
       %end;
       %else %do;
          %ds_words(string=&keyvars_t,delim=%str( ))
          %if &n_var ne &n_keyvars %then %do;
             %let err1=&prgname Error: Parameter KEYVARS_T should have equal number of items as in KEYVARS.;
             %let err2=&prgname Error: You have specified KEYVARS=&KEYVARS and KEYVARS_T=&KEYVARS_t..;
             %let nerr=2;
          %end;
          %else %do;
             %do i = 1 %to &n_KEYVARS;
                %let vtk&i=%upcase(%scan(&KEYVARS_t,&i));
             %end;
          %end;
       %end;
   %end;
   %else %do;
       %if %length(&KEYVARS_t) > 0 %then %do;
          %let err1=&prgname Error: Parameter KEYVARS_T should be left blank when KEYVARS is not used.;
          %let err2=&prgname Error: You have specified KEYVARS_T=&KEYVARS_t..;
          %let nerr=2;
       %end;
   %end;

   ****parse models****;
   %let n_models=0;
   %if &models ne %then %do;
      %ds_words(string=&models,delim=%str(#))
      %let n_models=&n_var;
      %do i=1 %to &n_models;
         %global model&i;
         %let model&i=%unquote(&&cell&i);
         %let myGlobal=&myGlobal model&i;

         /***
         %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&&model&i)%str( )))=0 %then %do;
           %let invars=&invars &&model&i;
         %end;
         ***/
/***%put model&i=&&model&i;***/
      %end;

      %do i=1 %to &n_models;
         %let pos=%index(&&model&i,%str(:));
/***%put pos=&pos;***/
         %if &pos=0 %then %do;
            %let err1=&prgname Error: Missing ':' in model &&model&i... It is used in place of '='.;
            %let nerr=1;
         %end;
         %ds_words(string=&&model&i,delim=%str( :))
         %global n_modelvars&i;
         %let n_modelvars&i=%eval(&n_var);
         %let myGlobal=&myGlobal n_modelvars&i;

/***%put n_modelvars&i=&&n_modelvars&i;***/
         %do j=1 %to &&n_modelvars&i;
            %global modelvar&i&j;
            %let modelvar&i&j=%unquote(&&cell&j);
            %let myGlobal=&myGlobal modelvar&i&j;
/***%put modelvar&i&j=&&modelvar&i&j;***/

            %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&&modelvar&i&j)%str( )))=0 %then %do;
               %let invars=&invars &&modelvar&i&j;
            %end;

         %end;
      %end;
   %end;

   ****parse modelclass****;
   %let n_modelclass=0;
   %if &modelclass ne %then %do;
      %ds_words(string=&modelclass,delim=%str(#))

      %let n_modelclass=&n_var;
      %do i=1 %to &n_modelclass;
         %global modelclass&i;
         %let modelclass&i=%unquote(&&cell&i);
         %let myGlobal=&myGlobal modelclass&i;

         /***
         %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&&modelclass&i)%str( )))=0 %then %do;
           %let invars=&invars &&modelclass&i;
         %end;
         ***/
/***%put modelclass&i=&&modelclass&i;***/

         %if %upcase(&&modelclass&i)=NULL %then %do;
             %let modelclass&i=;
         %end;
      %end;

      %do i=1 %to &n_modelclass;
         %ds_words(string=&&modelclass&i,delim=%str( ))
         %global n_modelclassvars&i;
         %let n_modelclassvars&i=%eval(&n_var);
         %let myGlobal=&myGlobal n_modelclassvars&i;
/***%put n_modelclassvars&i=&&n_modelclassvars&i;***/

         %do j=1 %to &&n_modelclassvars&i;
            %global modelclassvar&i&j;
            %let modelclassvar&i&j=%unquote(&&cell&j);
            %let myGlobal=&myGlobal modelclassvar&i&j;
/***%put modelclassvar&i&j=&&modelclassvar&i&j;***/

            %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&&modelclassvar&i&j)%str( )))=0 %then %do;
               %let invars=&invars &&modelclassvar&i&j;
            %end;

         %end;
      %end;
   %end;
   %else %do;
      %do i = 1 %to &n_models;
         %global modelclass&i;
         %let modelclass&i=;
         %let myGlobal=&myGlobal modelclass&i;
      %end;
   %end;

   ****check input dataset existence****;
   %ds_chkfile(indsn=&data)

   %if %length(&err1) > 1 %then %goto endvalidate;

   ****check STRATUM/RATE/MOS/WGT syntax valid?****;
   %let prnvars=&invars;
   %ds_chkparam(type=wgt,var=&wgt)
   %ds_chkparam(type=mos,var=&mos)
   %ds_chkparam(type=stratum,var=&stratum)
   %ds_chkparam(type=rate,var=&rate)
   %ds_chkparam(type=biasvar,var=&biasvar)

/*%put; */
/*%put total input string (invars)=&invars;   */
/*%put;*/

   ****check if variables in dataset****;
   %ds_chkvar(in_file=&data,in_list=&invars,out_list=&outvars)

   ****check if boundary is part of swapcell****;
   %if %length(&boundary) > 0 %then %do;
       %if %index(%quote(%str( )%upcase(&swapcell%str( ))),%quote(%str( )%upcase(&boundary)%str( ))) ne 1 %then %do;
           %let err1=&prgname Error: BOUNDARY should be the left most variable(s) in SWAPCELL.;
           %let err2=&prgname Error: You have specified SWAPCELL=&swapcell and BOUNDARY=&boundary..;
           %let nerr=2;
       %end;
   %end;

   ****check if certflag has valid values 1/0 ****;
   %if %length(&certflag) > 0 %then %do;
      %let nBadCertFlag=0;
       proc sql noprint;
          select count(*) into :nBadCertFlag
          from &data
          where &CertFlag is null or &CertFlag not in (0,1);
       quit;
      %if &nBadCertFlag ne 0 %then %do;
         %let err1=&prgname Error: Parameter CERTFLAG=&certflag has values other than 1 or 0.;
         %let nerr=1;
      %end;
   %end;

%if &debug=1 %then %do;
%put n_boundvar=&n_boundvar;
%put n_cellvar=&n_cellvar;
%end;

   ****parse tolflag****;
   %if %index(&tolflag,#)=0 %then %do;
      %if &tolflag < 1 %then %let tolflag=&tolflag#45#1.96#1.1;
      %else %if &tolflag=45 %then %let tolflag=0.1#&tolflag.#1.1;
      %else %if &tolflag=1.96 %then %let tolflag=0.1#45#&tolflag.#1.1;
      %else %if &tolflag=1.1 %then %let tolflag=0.1#45#1.96#&tolflag;
   %end;
   /***
   %if %index(&tolflag,#)=1 %then %let %tolflag=0.1#&tolflag;
   %if %index(&tolflag,#)=%length(&tolflag) %then %let tolflag=&tolflag%str(#)45;
   ***/
   %ds_words(string=&tolflag,delim=%str(#))
   %do i=1 %to &n_var;
      %let tolflag&i=&&cell&i;
   %end;
   %if &tolflag1= %then %let tolflag1=0.1;
   %if &tolflag2= %then %let tolflag2=45;
   %if &tolflag3= %then %let tolflag3=1.96;
   %if &tolflag4= %then %let tolflag4=1.1;

   ****parse listpair****;
   %if %index(&listpair,#)=1 %then %let %listpair=S#&listpair;                   /* listpair=#1 */
   %if %index(&listpair,#)=%length(&listpair) %then %let listpair=&listpair.1.0; /* listpair=S# */
   %if %index(&listpair,#)=0 %then %do;
       %if %upcase(&listpair)=B or %upcase(&listpair)=S %then %let listpair=&listpair%str(#)1.0;
       %else %let listpair=S#&listpair;
   %end;
   %ds_words(string=&listpair,delim=%str(#))
   %let listpair1=&cell1;
   %let listpair2=%unquote(&cell2);
   %if not (%upcase(&listpair1)=B or %upcase(&listpair1)=S) %then %do;
       %let err1=&prgname Error: LISTPAIR must start with S or B. You have specified &listpair;
       %let nerr=1;
   %end;
   data _null_;
      if not (0 <= &listpair2 and &listpair2 <=1.0) then
         call symput("err1","1");
      if &listpair2 = 0 then
         call symput("lispair2","0");
   run;
   %if &err1=1 %then %do;
      %let err1=&prgname Error: LISTPAIR must end with a number in [0,1]. You have specified &listpair;
      %let nerr=1;
   %end;

   /*parse BOUNDARY_MD,SWAPVARS_MD,KEYVARS_MD,KEYOUT_MD if specified*/
   /*new feature ESSIN 2015*/
   %local MDparam nMDparam ;
   %local i j n nvar aword bword cword aparam aparamval ;

   %let MDparam=BOUNDARY_MD SWAPVARS_MD KEYVARS_MD KEYOUT_MD;                         ;
   %let nMDparam=%sysfunc(countw(&MDparam));

   %do i=1 %to &nMDparam;
      %let aWord=%scan(&MDparam, &i);
      %let bWord=%str(&)%quote(&aWord);
      %let cWord=%unquote(&bWord);

      %let j=%eval(%index(&aword,%str(_))-1);
      %let aparam=%substr(&aword,1,&j);
      %let bWord=%str(&)%quote(&aparam);
      %let aparamval=%unquote(&bWord);

      %if %length(&cword)>0 %then %do;
         %if %length(&aparamval)=0 %then %do;
            %let err1=&prgname Error: Parameter &aword. should be left blank when no &aparam was specified.;
            %let err2=&prgname Error: You have specified &aword=&cword..;
            %let nerr=2;
         %end;
         %else %do;
            %let n=%eval(%sysfunc(countc(&cword,%str(#)))+1);
            %let nvar=%sysfunc(countw(&aparamval));

            %if &n > &nvar %then %do;
               %let err1=&prgname Error: Parameter &aword should have equal number of items as in &aparam..;
               %let err2=&prgname Error: You have specified &aparam.=&aparamval and &aword=&cword..;
               %let nerr=2;
            %end;
         %end;
      %end;
   %end;

%endvalidate:
%MEND DS_VALIDATE;

*****SUBROUTINE VALIDATES PARAMETERS****;
%MACRO DS_CHKPARAM(TYPE=,VAR=);

   %if %length(&err1) >0 %then %goto endchkparam;

   %local isVar isFunction msg1 msg2 msg3 msg4;
   %let isVar=0;
   %let isFunction=0;

   %if &type=rate %then %do;
       %let msg1=&prgname Error: Parameter RATE must be a single variable or a number. You have specified &rate.%str(.);
       %let msg2=&prgname Error: Parameter RATE must be a value between '(0, 1]'. You have specified &rate.%str(.);
       %let msg3=&prgname Error: Parameter RATE must be constant within a stratum.;
       %let msg4=&prgname Error: Parameter RATE must be values between '(0, 1]'. Please check your variable '&rate.'%str(.);
       %let rateisnum=0;
   %end;
   %else %if &type=mos %then %do;
       %let msg1=&prgname Error: Parameter MOS must be a single variable or a value. You have specified &mos..;
       %let msg2=&prgname Error: Parameter MOS must be 1 when entered as a number. You have specified &mos.%str(.);
       %let msg3=&prgname Error: Parameter MOS must have values greater than 0. Please check your variable '&mos.'%str(.);
   %end;
   %else %if &type=wgt %then %do;
       %let msg1=&prgname Error: Parameter WGT must be a single variable or a value. You have specified &wgt..;
       %let msg2=&prgname Error: Parameter WGT must be 1 when entered as a number. You have specified &wgt.%str(.);
   %end;
   %else %if &type=biasvar %then %do;
       %let msg1=&prgname Error: Parameter BIASVAR must be a single variable. You have specified &biasvar..;
   %end;
   %else %if &type=stratum %then %do;
       %let msg1=&prgname Error: Parameter STRATUM must be a single variable or a value. You have specified &stratum..;
       %let msg2=&prgname Error: Parameter STRATUM must be 1 when entered as a number. You have specified &stratum.%str(.);
   %end;

   %if %length(&VAR) > 0 %then %do;
      **** check type of &TYPE ****;
      data _null_;
         length a $ 32 ;
         a=upcase("&VAR");
         if indexc(upcase("&VAR"),'ABCDEFGHIJKLMNOPQRSTUVWXYZ_') gt 0 then do;
            call symput('isVar',"1");
         end;
         if indexc("&VAR",'+-*/() ') gt 0 then do;
            call symput('isFunction',"1");
         end;
      run;
   %end;

   %if &isFunction=1 and &isVar = 1 %then %do;
       %let err1=&msg1;
       %let nerr=1;
   %end;
   %else %if &isVar=1 %then %do;

      %if %index(%quote(%str( )%upcase(&invars)%str( )),%quote(%str( )%upcase(&var)%str( )))=0 %then
          %let invars = &invars &var. ;

      %if &type=stratum  or &type=wgt %then %do;
          %if %index(%quote(%str( )%upcase(&prnvars)%str( )),%quote(%str( )%upcase(&var)%str( )))=0 %then
              %let prnvars=&prnvars &var;
      %end;

   %end;
   %else %if &type=rate %then %do;
      %let rateisnum=1;
      **** check range of &TYPE ****;
      data _null_;
         if &rate <= 0 or &rate > 1.0 then do;
            call symput('err1',"&msg2");
            call symput("nerr","1");
         end;
      run;
   %end;
   %else %if (&type=mos or &type=wgt or &type=stratum) %then %do;
      data _null_;
         if "&var" ne "1" and "&var" ne "1.0" and "&var" ne "" then do;
            call symput('err1',"&msg2");
            call symput("nerr","1");
         end;
      run;
   %end;

%if &debug=1 %then %do;
%put type=&type;
%put var=&var;
%put isVar=&isVar;
%put isFunction=&isFunction;
%end;

%endchkparam:

%MEND DS_CHKPARAM;

%MACRO DS_VARVALID();
   %local i;
   data _null_;
      if _n_ = 1 then set &tmpdsn;
     %if %length(&wgt) > 0 and %index(&wgt,__) = 0 %then %do;
      if vtype(&wgt) = "C" then do;
         call symput("err1","&prgname Error: Parameter WGT must be a numeric variable.");
         call symput("err2","&prgname Error: You have defined it as a character variable.");
         call symput("nerr","2");
      end;
     %end;
     %if %length(&mos) > 0 and %index(&mos,__) = 0 %then %do;
      if vtype(&mos) = "C" then do;
         call symput("err1","&prgname Error: Parameter MOS must be a numeric variable.");
         call symput("err2","&prgname Error: You have defined it as a character variable");
         call symput("nerr","2");
      end;
     %end;
     %if %length(&b_var) > 0 %then %do;
      if vtype(&b_var) = "C" then do;
         call symput("nerr","2");
         call symput("err1","&prgname Error: Parameter BIASVAR must be a numeric variable.");
         call symput("err2","&prgname Error: You have defined it as a character variable.");
      end;
     %end;
     %if %length(&keyout) > 0 %then %do;
        %do i=1 %to &n_keyouts;
      if vtype(&&keyout&i) = "C" then do;
         call symput("nerr","2");
         call symput("err1","&prgname Error: Parameter KEYOUT must be a numeric variable.");
         call symput("err2","&prgname Error: You have defined &&keyout&i as a character variable.");
      end;
        %end;
     %end;
     %if %length(&models) > 0 %then %do;
        %do i=1 %to &n_models;
         %do j=1 %to &&n_modelvars&i;
          %if %index(%quote(%str( )%upcase(&&modelclass&i)%str( )),%quote(%str( )%upcase(&&modelvar&i&j)%str( )))=0 %then %do;
      if vtype(&&modelvar&i&j) = "C" then do;
         call symput("nerr","2");
         call symput("err1","&prgname Error: Model variable &&modelvar&i&j must be numeric or in MODELCLASS.");
         call symput("err2","&prgname Error: You have defined &&modelvar&i&j as character and Ordinal.");
      end;
          %end;
         %end;
        %end;
     %end;
     /*
     %if %length(&boundary) > 0 %then %do;
        %do i=1 %to &n_boundvar;
        %if &&vtb&i=O %then %do;
         %let bv=%scan(&boundary,&i);
      if vtype(&bv) = "C" then do;
         call symput("nerr","2");
         call symput("err1","&prgname Error: Variable &bv must be a numeric variable if its type is O.");
         call symput("err2","&prgname Error: You have defined &bv as a character variable.");
      end;
        %end;
        %end;
     %end;
     %if %length(&swapvars) > 0 %then %do;
        %do i=1 %to &n_swapvars;
        %if &&vts&i=O %then %do;
      if vtype(&&swapvar&i) = "C" then do;
         call symput("nerr","2");
         call symput("err1","&prgname Error: Variable &&swapvar&i must be a numeric variable if its type is O.");
         call symput("err2","&prgname Error: You have defined &&swapvar&i as a character variable.");
      end;
        %end;
        %end;
     %end;
     %if %length(&keyvars) > 0 %then %do;
        %do i=1 %to &n_keyvars;
        %if &&vtk&i=O %then %do;
      if vtype(&&keyvar&i) = "C" then do;
         call symput("nerr","2");
         call symput("err1","&prgname Error: Variable &&keyvar&i must be a numeric variable if its type is O.");
         call symput("err2","&prgname Error: You have defined &&keyvar&i as a character variable.");
      end;
        %end;
        %end;
     %end;
     */
      stop;
   run;

%MEND DS_VARVALID;

%MACRO DS_CHKRANGE(TYPE=,VAR=);
   %if &type=rate and &rateisnum ne 1 %then %do;
      %let msg3=&prgname Error: Parameter RATE must be constant within a stratum.;
      %let msg4=&prgname Error: Parameter RATE must be values between '(0, 1]'. Please check your variable '&rate.'%str(.);
      %put %str(            )**** check if &VAR is constant within &stratum ****;

      proc means nway data=&tmpdsn noprint;
      %if %str(&stratum) ne __stratum %then %do;
         class &stratum;
      %end;
         var &rate;
         output out=__tmp1(keep=__max __min) max=__max min=__min;
      run;
      data _null_;
         if eof then do;
            if __noteq=1 then do; call symput("err1","&msg3"); call symput("nerr","1"); end;
            if __notin=1 then do; call symput("err1","&msg4"); call symput("nerr","1"); end;
         end;
         retain __noteq __notin 0;
         set __tmp1 end=eof;
         if __max ne __min then do;
            __noteq=1;
         end;
         if (__max<=0 or __max>1.0) or (__min<=0 or __min>1.0) then do;
            __notin=1;
         end;
      run;
   %end;

   %if &type=mos and &mos ne __mos %then %do;
      %let msg3=&prgname Error: Parameter MOS must have values greater than 0. Please check your variable '&mos.'%str(.);
      **** check if &VAR is greater than 0 ****;
      proc means data=&tmpdsn noprint;
         var &mos;
         output out=__tmp1(keep=__max __min) max=__max min=__min;
      run;
      data _null_;
         set __tmp1;
         if __max<=0 or __min<=0 then do; call symput("err1","&msg3"); call symput("nerr","1"); end;
      run;
   %end;

%MEND DS_CHKRANGE;

*****SUBROUTINE VALIDATES PARAMETERS****;
%MACRO DS_CHKMISS(TYPE=,VAR=);
   %let namevar=&var;
   %if &type=biasvar %then %do;
      %local pos;
      %let pos=%index(&var,_I);
      %if &pos = %eval(%length(&var)-1) %then
         %let namevar=%substr(&var,1,%eval(%length(&var)-2));
   %end;

   %let missingN=0;
   %let cntID=0;
   %let msg1=&prgname Error: Variable %upcase(&type)=&var has missing value(s).;
   %let msg2=&prgname Error: You will need to impute for missing data, or ;
   %let msg3=&prgname Error: recode the variables to have a nonmissing code.;

   %if (%length(&var) > 0 and &type ne rate) or (&type=rate and &rateisnum ne 1) %then %do;
      **** check missing values in &TYPE ****;

      %if &type=id %then %do;
         proc sql noprint;
            select count (distinct &id) into :cntID from &tmpdsn;
         quit;

         %if &debug=1 %then %do;
         %put nobs=&nobs;
         %put cntID=&cntID;
         %end;

         %if &nobs ne %trim(&cntID) %then %do;
            %let err1=&prgname Error: ID variable &ID is not unique.;
            %let err2=&prgname Error: Please double check.;
            %let nerr=2;
         %end;
      %end;

      proc sql noprint;
         select count (*) into :missingN from &tmpdsn
         where &var is null;
      quit;

      %if &missingN ne 0 %then %do;
         %let err1=&msg1;
         %let err2=&msg2;
         %let err3=&msg3;
         %let nerr=3;
      %end;
   %end;
%MEND DS_CHKMISS;

*****MACRO TO VERIFY IF FILE EXISTS*****;
%macro ds_chkfile(indsn=);
   %if %sysfunc(exist(&indsn)) %then %do;
/*       %let dsid=%sysfunc(open(&indsn,i));  */
/*       %put NOTE: data set &indsn exists.;  */
      %ds_chkobs(indsn=%upcase(&indsn))
   %end;
   %else %do;
      %let err1=&prgname Error: Data set &indsn does not exist.;
   %end;
%mend ds_chkfile;

*****MACRO TO CHECK IF INDD IS EMPTY*****;
%macro ds_chkobs(indsn=);
   %local myobs;
   %if %index(&indsn,.) %then %do;
      %let libn=%QUOTE(%SCAN(&indsn,1,.));
      %let memn=%QUOTE(%SCAN(&indsn,2,.));
   %end;
   %else %do;
      %let libn=WORK;
      %let memn=&indsn;
   %end;

   PROC SQL noprint;
     SELECT NOBS INTO :nobs from SASHELP.VTABLE
     WHERE LIBNAME="&libn" AND MEMNAME="&memn";
   quit;

   %if &nobs=0 %then %do;
      %let err1=&prgname Error: Data set &indsn has 0 obs;
   %end;
   %else %do;
      %let nobs=&nobs; /* this gets ride of the leading blanks */
      %put NOTE: Data set &indsn has &nobs obs;
   %end;
%mend ds_chkobs;

*****MACRO TO VERIFY IF LIB EXISTS*****;
%macro ds_chklib(libname=);
   %if %sysfunc(libref(&libname)) %then %do;
       %let err1=&prgname Error: libref &libname not defined ;
   %end;
%mend ds_chklib;

*****MACRO TO CONSTRUCT STRINGS*****;
%macro ds_indent(instring=,inlen=,delim=);
   %local i n word;
   %do i = 1 %to 5;
      %let chop&i=;
   %end;
   %let i=1;
   %let n=1;
   %let word=%nrbquote(%scan(&instring,&n,&delim));
   %do %while(&word ne );
      %if %length(&&chop&i &word) > &inlen %then %let i=%eval(&i+1);
      %let chop&i = %trim(&&chop&i) %trim(&word);
      %let n=%eval(&n+1);
      %let word=%nrbquote(%scan(&instring,&n,&delim));
   %end;
   %let n=%eval(&n-1);
   %let nchop=&i;
%mend ds_indent;

*****MACRO TO CHECK VARIABLES FOR CONFLICT****;
%MACRO DS_CHKVAR
  (IN_FILE=,     /* DATA SET NAME TO BE CHECKED */
   IN_LIST=,     /* INCOMING VARIABLES TO CHECK */
   OUT_LIST=);   /* OUTGOING VARIABLES TO CHECK */

   %local i ninvar noutvar word notfound alreadyin allvars InLib InDsn;

   %let InLib=%scan(&IN_FILE, 1);
   %let InDsn=%scan(&IN_FILE, 2);
   %if &InDsn= %then %do;
      %let InDsn=&InLib;
      %let InLib=WORK;
   %end;

   %let ninvar=%eval(%sysfunc(countc(&in_list," "))+1);
   %let noutvar=%eval(%sysfunc(countc(&out_list," "))+1);

   proc sql noprint;
      select upcase(name) into :allvars separated by ' '
      from dictionary.columns
      where libname=upcase("&InLib") and memname=upcase("&InDsn")
      ;
   quit;
%put allvars=&allvars;
   %let i=1;
   %do %while (&i<=&ninvar);
      %let word=%scan(&in_list,&i,%str( ));
      %if %index(%str( )&allvars%str( ),%str( )%upcase(&word)%str( ))=0 %then %do;
         %let notfound=&notfound &word;
      %end;
      %let i=%eval(&i+1);
   %end;

   %let i=1;
   %do %while (&i<=&noutvar);
      %let word=%scan(&out_list,&i,%str( ));
      %if %index(%str( )&allvars%str( ),%str( )%upcase(&word)%str( ))=0 %then %do;
         %let alreadyid=&alreadyin &word;
      %end;
      %let i=%eval(&i+1);
   %end;

   %if %length(&notfound)>0 %then %do;
      %LET ERR1=%STR(&prgname Error: NOT ALL VARIABLES SPECIFIED);
      %LET ERR2=%STR(                FOUND ON DATASET "&IN_FILE".);
      %LET ERR3=%STR(                PLEASE RECTIFY AND RERUN.);
      %LET ERR4=%STR(                LIST: &notfound);
      %LET NERR=4;
   %end;

   %if %length(&alreadyin)>0 %then %do;
      %LET ERR1=%STR(&prgname Error: ONE OR MORE OUTPUT VARIABLE(S) FOUND);
      %LET ERR2=%STR(                ALREADY EXIST ON DATASET "&IN_FILE".);
      %LET ERR3=%STR(                PLEASE RECTIFY AND RERUN.);
      %LET ERR4=%STR(                LIST: &alreadyin);
      %LET NERR=4;
   %end;

%MEND DS_CHKVAR;

*****PRINTS INFORMATION PAGE*****;
%MACRO DS_INFO();
   DATA _NULL_;
      FILE PRINT N=PS LS=&LS;
      TITLE3 "%UPCASE(&prgname) REPORT";
      TITLE4 "THE INFORMATION PAGE";
      PUT //
"DATASWAP MACRO VERSION #:                          " "&vernum"   //
"INPUT DATA SET:                                    "
    %IF %QUOTE(&DATA) NE %THEN                      "&DATA."        //;
    %ELSE                                           "NOT APPLICABLE"//;
"OUTPUT DATA SET:                                   "
    %IF %QUOTE(&OUT) NE %THEN                       "&OUT."     //;
    %ELSE                                           "NOT SPECIFIED" //;
"OBSERVATIONS IN INPUT DATA SET:                    " "&NOBS"       //
    %IF %length(&seed)=0 or &seed=0 %then
"RANDOM SEED:                                       " "&ActualSEED. (Generated with clock(0))"//;
    %else
"RANDOM SEED:                                       " "&SEED."//;
"CASE IDENTIFICATION:                               " "&ID."        //
"MEASURE OF SIZE:                                   "
    %IF %UPCASE(&MOS)=__MOS %THEN                   "1 (Default)"   //;
    %ELSE                                           "&MOS."         //;
"STRATUM:                                           "
    %IF %UPCASE(&STRATUM)=__STRATUM %THEN            "NOT SPECIFIED" //;
    %ELSE                                           "&STRATUM"      //;
"DESIRED SWAPPING RATE:                             " "&rate"       //
"NON-CERTAINTY SELECTION ORDER:                     "
    %IF %QUOTE(&SORTVARS) NE %THEN                  "&SORTVARS"      //;
    %ELSE                                           "NOT SPECIFIED" //;
"SWAP CELL DEFINITION:                              " "&saveSWAPCELL."  //
"TOTAL NUMBER OF CELLS:                             " "&LVAL."      //
"HARD BOUNDARY:                                     "
    %IF %QUOTE(&BOUNDARY) NE %THEN                  "&BOUNDARY"     //
"BOUNDARY VARIABLE TYPE:                            " "&boundary_t" //;
    %ELSE                                           "NOT SPECIFIED" //
"BOUNDARY VARIABLE TYPE:                            " "NOT APPLICABLE" //;
"PRIMARY SWAP VARIABLE(S):                          " "&saveSWAPVARS."  //
"SWAPVARS VARIABLE TYPE:                            " "&swapvars_t." //
"LINKED SWAP VARIABLE(S):                           "
    %IF %QUOTE(&LINKSWAP) NE %THEN %DO;
        %DS_INDENT(instring=&LINKSWAP,inlen=%EVAL(&LS-52),delim=%str( ))
                                                    "&CHOP1"/
        %IF &NCHOP > 1 %THEN %DO;
           %DO I=2 %TO &NCHOP;
"                                                   " "&&CHOP&I."    /
           %END;
        %END;
/
    %END;
    %ELSE                                           "NOT SPECIFIED" //;
"BIAS VARIABLE:                                     "
    %IF &SWAPMETH=2 AND &N_SWAPVARS NE 1 %THEN      "< Dynamic >"//;
    %ELSE %IF %QUOTE(&BIASVAR) NE %THEN             "&BIASVAR" //;
    %ELSE                                           "&saveB_var (Default)" //;
"CASE WEIGHT:                                       "
    %IF %UPCASE(&WGT)=__WGT %THEN                   "1 (Default)"    //;
    %ELSE                                           "&WGT."         //;
%if %length(&varstrat)>0 %then
"VARIANCE STRATUM:                                  " "&varstrat."     //;
%if %length(&varunit)>0 %then
"VARIANCE UNIT:                                     " "&varunit."     //;
/*
"REPORTS REQESTED:                                  " "&REPORTS"    //
*/
"IMPUTE OPTION:                                     "
     %if %upcase(%substr(&impute,1,1)) = Y %then    "Yes (Default)"//;
     %else                                          "No"//;
"MISSINGDEF:                                        "
     %if %upcase(%substr(&impute,1,1)) ne Y %then   "NOT APPLICABLE"//;
     %else %if %length(&MISSINGDEF)>0 %then         "&MISSINGDEF"//;
     %else                                          "NOT SPECIFIED"//;
%if %upcase(%substr(&impute,1,1)) = Y %then %do;
   %do i = 1 %to &n_swapvars;
      %if &&nmiss&i = 0 and %length(&&missset&i) > 0 %then %do;
"(&&swapvar&i.._I not created because there are no missing values)."//
      %end;
   %end;
%end;
"SWAPPING METHOD:                                   "
%if &swapmeth=1 %then                               "&SWAPMETH (Standard)" //;
%else                                               "&SWAPMETH (Balanced)" //;
"KEY OUTPUT VARIABLE:                               "
    %IF %QUOTE(&KEYOUT) NE %THEN                    "&KEYOUT"      //;
    %ELSE                                           "NOT SPECIFIED" //;
"OTHER KEY VARIABLES:                               "
    %IF %QUOTE(&KEYVARS) NE %THEN %DO;

        %DS_INDENT(INSTRING=&KEYVARS,INLEN=%EVAL(&LS-52),DELIM=%STR( ))
                                                    "&CHOP1."      /
        %IF &NCHOP > 1 %THEN %DO;
           %DO I=2 %TO &NCHOP;
"                                                   " "&&CHOP&I."    /
           %END;
        %END;
/
    %END;
    %ELSE                                           "NOT SPECIFIED" //;
"KEYVARS VARIABLE TYPE:                             "
    %IF %QUOTE(&KEYVARS_T) NE %THEN %DO;

        %DS_INDENT(INSTRING=&KEYVARS_T,INLEN=%EVAL(&LS-52),DELIM=%STR( ))
                                                    "&CHOP1."      /
        %IF &NCHOP > 1 %THEN %DO;
           %DO I=2 %TO &NCHOP;
"                                                   " "&&CHOP&I."    /
           %END;
        %END;
/
    %END;
    %ELSE                                           "NOT SPECIFIED" //;
"USER-SPECIFIED MODELS:                             "
    %IF &n_models>0 %THEN %do;
                                                    "&model1"/
       %do i = 2 %to &n_models;
"                                                   " "&&model&i." /
       %end;
/
    %end;
    %ELSE                                           "NONE SPECIFIED" //;
"CLASS VARIABLES IN MODELS:                         "
    %IF &n_modelclass>0 %THEN %do;
                                                    "&modelclass1"/
       %do i = 2 %to &n_modelclass;
"                                                   " "&&modelclass&i." /
       %end;
/
    %end;
    %ELSE                                           "NONE SPECIFIED" //;
/***
%if %length(&corrpred)> 0 %then
%if %upcase(%substr(&corrpred,1,1))=_ %then
"COMPUTE CORRELATION OF REGRESSION PREDICTED VALUES:" "NOT SPECIFIED" //;
%else
"COMPUTE CORRELATION OF REGRESSION PREDICTED VALUES:" "&corrpred." //;
***/
"TOLERANCE FLAG:                                    "
    %IF &TOLFlAG=0.1#45#1.96#1.1 %THEN              "&TOLFLAG (Default)" //;
    %ELSE                                           "&TOLFLAG" //;
"SWAPPING PAIR OUTPUT CONTROL:                      "
    %IF %UPCASE(&LISTPAIR)=S#1.0 %THEN              "&LISTPAIR (Default)" //;
    %ELSE                                           "&LISTPAIR" //;
"MAXIMUM NUM. OF CATEGORIES FOR DRB TABLE VARIABLES:"
    %IF &MAXCAT=20 %THEN                            "&MAXCAT (Default)" //;
    %ELSE                                           "&MAXCAT" //;
/*
"OUTPUT SEQUENTIAL CELL NUMBER (CELLN)              " "&CELLN"      //
"OUTPUT SAMPLE FLAG (SAMPFLAG):                     " "&SAMPFLAG"   //
"OUTPUT SELECTION WEIGHT (SELWGT):                  " "&SELWGT"     //
*/
"TOTAL NUMBER OF ITERATIONS:                        " "&NITER"      //
    %IF %LENGTH(&ERR1) > 0 %THEN
"PROGRAM ABORTED PREMATURELY.                       " // ;
   ;
   RUN;
%MEND DS_INFO;



*This macro determines the certainty PSUs from the stratum allocation;
*file (&allocfil) before removal of certainties using the measure of size;
*(&meas) as a basis for determining the probability of selection.;
*A certianty PSU is a unit  with probability of selection ;
*greater than or = to 1. Two variables are added to the sampling frame;
*(&frame). &certind = blank if PSU is noncertainty, or 'schcert' if the;
*PSU is a certainty. The other variable is &stratumr which is a new;
*stratum variable which divides each stratum (&stratum) into two new;
*stratum - one for certainties, if there are any, and one for;
*noncertainties, if there are any. This is how the Bootstrap macro;
*assumes the stratum are set up. A new allocation file is generated ;
*with appropriate sample sizes for the new stratum (&stratumr). This;
*file includes the &stratumr, the sample partion variable (&samppart);
* needed for defining sampling groups, the certainy indicator and;
*the sample size (n). This is the allocation file the bootstrap macro;
*is assuming.;
*;

%macro Certainties(
   frame=,
   allocfil=,
   pmeas=,
   stratum=,
   stratumr=,
   meas=,
   nwallocf=,
   samppart=,
   certind=);

%local tmpdsn;
%local i j;

data __prealloc;
   set &allocfil;
run;

proc sort data=__prealloc;
   by &stratum;
run;

proc sort data=&frame;
   by &stratum descending &meas;
run;

proc summary nway data=&frame;
   var &meas;
   by &stratum;
   output out=__totalst(drop=_type_ _freq_) sum=__tottch;
run;

%let cer=s;
%let ncer=;

data &frame(drop=__tottch __totalx __nx __nf __n rename=(__pmeasxx=&pmeas))
     &nwallocf(keep=&stratumr &certind /* &samppart */  __n);
   merge &frame(in=in) __totalst __prealloc;
   by &stratum;
   retain __nf __totalx __nx;
   length &certind $ 1 ;
   if in;
   if first.&stratum then do;
      __totalx=__tottch;
      __nf=__n;
      __nx=__n;
   end;
   ***&certind='       ';
   &certind=' ';
   __pmeasxx=(&meas/__totalx)*__nx;

***put &meas= __totalx= __nx= __pmeasxx=;

   if __pmeasxx ge 1 then do;
      ***&certind='schcert';
      &certind='c';
      __totalx=__totalx-&meas;
      __nx=__nx-1;
      __pmeasxx=1;
   end;

   ***if &certind='schcert' then &stratumr=&stratum || put("&cer",$char8.);
   ***else &stratumr=&stratum || put("&ncer",$char8.) ;

   &stratumr = &stratum || &certind;

   output &frame;

   if last.&stratum then do;
      if __nx=0 or __nx=__n then do;
         ***if __nx=0 then &certind='schcert';
         ***else &certind='       ';
         if __nx=0 then &certind='c';
         else &certind=' ';
         output &nwallocf;
      end;
      else do;
         __n=__nx;
         ***&certind='       ';
         ***&stratumr=&stratum || put("&ncer",$char8.);
         &certind=' ';
         &stratumr=&stratum || &certind;
         output &nwallocf;
         __n=__nf-__nx;
         ***&certind='schcert';
         ***&stratumr=&stratum || put("&cer",$char8.);
         &certind='c';
         &stratumr=&stratum || &certind;
         output &nwallocf;
      end;
   end;
run;
%mend Certainties;


* This macro selects n schools (PSUs) within a stratum systematically;
* It will replicate this process only once. It will also compute sample;
* weights. This macro also differs from the others in that a unit can ;
* have a probability of selection larger than 1. It then become;
* possible to select the unit more than once. When this happens, the;
* selection variable will indicate the number of times the PSU is;
* selected.;
*;
* The assumptions are:;
*;
*         The input file data is sorted by stratnam and other sort;
*         variables;
*;
*         The sum of the measure of sizes (size) within a stratum;
*           equals n;
*;
*         variable Certind identifies certainty schools by the;
*         characters schcert;
*         If a school is selected with certainty then the measure;
*         of size is set equal to one.;
*;
*                    variables added to the frame file;
*;
*         The selection is specified by variable samp1.;
*                0-not selected;
*                1-selected in the stratum once;
*                n-selected n times;
*;
*         randn the n th random number for the stratum:';
*          it has two pieces:;
*           left most number is the random selection between 0 and 1;
*           right number specifies which replicate the random number;
*           refers to;
*;
*  The frame with measure of size (size) and stratum (stratnam);
*   has a name specified by data=name of file;
*;
*  A seed for the random number generator is specified by;
*  seed=N, N a number less than 2**31-1;
*;
*  cummeas is the cumulative measure of size;
* %macro sel2pstr(data=univdat,stratnam=strata,namsel=select1,;
* size=meas, seed=12345,samsz=file,certind=level,schwtprf=btwsch,;
* botn=1);
*;
*      data=frame file name;
*;
*      stratnam=name of stratum variable;
*      namsel= is a macro variable specifing name of variable to be;
*              used as an indicator for which PSUs have been selected.;
*              It should have a char $ 1 format.;
*      size = name of measure of size variable;
*      seed is a number less than 2**31-1 to start the random numbers;
*      samsz is a file of stratum sample sizes sorted by stratnam;
*             each certainty unit is a separate stratum;
*             the name of the variable on samsz is n;
*      certind is a flag specifing certianty PSUs. If certainty the ;
*               value is 'schcert';
*      schwtprf is the prefix for the name of the weight variable. The;
*                weight name will have the value of botn added at the;
*                end of the prefix.;
*      botn   is a number associated with the sample being selected.;
*             (i.e., this is the botn sample of the 48 bootstrap;
*              sample).;
*;

%macro NonCertainties(
   data=univdat,
   stratumr=,
   namsel=select1,
   size=meas,
   seed=12345,
   sortvars=,
   samsz=file,
   certind=level,
   schwtprf=btwsch,
   botn=1);

%local nsample;

*;
* generate the random numbers;
*;

%let nsample=1;

data __ran;
   keep &stratumr __rand __n;
   set &samsz;
   by &stratumr;
   if first.&stratumr then do;
      do __sample= 1 to &nsample;
         __rand=put(ranuni(&seed),5.4) || put(__sample,4.0) ;
         output;
      end;
   end;
run;

%if &debug=1 %then %do;
proc print data=__ran;
   title3 "debug : __ran step 1 in noncertainties";
run;
%end;

proc sort data=__ran;
   by &stratumr __rand;
run;

data __ran;
   set __ran;
   by &stratumr;
   if first.&stratumr then output;
   else do;
      __n=.;
      output;
   end;
run;

%if &debug=1 %then %do;
proc print data=__ran;
   title3 "debug : __ran before transpose";
run;
%end;

proc transpose prefix=__rand out=__randt;
   by &stratumr;
   var __rand;
   copy __n;
run;

%if &debug=1 %then %do;
proc print data=__randt;
   title3 "debug : __randt after transpose";
run;
%end;

proc datasets nolist;
   delete __ran;
quit;

*;
* select the samples;
*;

%if &debug=1 %then %do;
proc print data=&data;
   title3 "debug : &data before non-cert selection";
run;
%end;

data &data;
   length &NAMSEL $ 1;
   merge &data(in=in) __randt;
   array random {&nsample}  __rand1;
   array selectun{&nsample} &namsel;
   array ranstart {&nsample} __rans1;
   array sampnum {&nsample} __samp1;
   retain __rans1 __samp1 __ks __iter;
   by &stratumr;
   if in;
   drop __j _name_  __sample;
   drop __rand1 __cummeas __n __rans1;
   drop __samp1 __ks __iter;
   if first.&stratumr then do ;
      __cummeas=0;
      do __j = 1 to &nsample;
         /***put random(__j)= __rand1=;***/
         *ranstart{__j}=input(substr(random{__j},1,5), 8.4);
         *sampnum{__j}=input(substr(random{__j},6,4), 8.0);
         ranstart{__j}=substr(random{__j},1,5);
         sampnum{__j}=substr(random{__j},6,4);
      end;
      __ks=1;
      __iter=0;
   end;

   do __j= 1 to &nsample;
      selectun{__j}='0';
      &schwtprf.&botn=0;
   end;


   *;
   * do selection for non certainty schools;
   *;

   if &certind ne "c" then do;
      __cummeas+&size;
      do while (ranstart{__ks}+__iter le __cummeas);
         __sample=sampnum{__ks};
         selectun{__sample}=selectun{__sample} + 1;
         *selectun{__sample}='1';
         &certind="n";
         if __ks lt &nsample then __ks=__ks+1;
         else do;
            __ks=1;
            __iter=__iter+1;
         end;
      end;
      if __sample ne . then do;
         *&schwtprf.&botn=input(selectun{__sample},8.0)/&size;
         &schwtprf.&botn=selectun{__sample}/&size;
         ***put __ks= __iter= __sample= &size= __cummeas= ;
      end;
      else do;
         ***put __ks= __iter= __sample= &size= __cummeas= ;
      end;
   end;

   *;
   * do selection for certainty schools;
   *;

   else do;
      do __j=1 to &nsample;
         selectun{__j}='1';
         &schwtprf.&botn=1;
      end;
      &size=1;
   end;
run;

proc datasets nolist;
   delete __randt;
quit;

%mend NonCertainties;

*;
* this macro does the swapping;
*;
*;
* Data is the sample;
*;
* sdata is the file containing the actual cases within the file data;
*       that are required to be swapped.;
*;
* cell represents cells that are comprised of the concatination of the;
*      swapping variables. Cell must have integer values starting at 1;
*      and continually consecutively to the last value of cell.;
*;
* variable is the swapping variable to be used to compute and compare;
*          the swapping bias.;
*;
* id is the identification variable for each record on the file data.;
*;
* swaps is the file containing the final swaps and the corresponding;
*       swapping partner.;
*;
*     There are two variables on this file sid, which represents the;
*     id for the swap and &id which represents the id for the swapping;
*     partner.;
*;
** lval is the largest value of the &cell variable.;
*;
%macro Swap(
   data=input,
   sdata=swap,
   swaps=swaps,
   lval=,
   seed=,
   boundary=,
   cell=,
   celln=,
   id=,
   swapvar=,
   biasvar=,
   wgt=
   );

/***
%put in macro swap cell=&cell;
%put in macro swap swapvar=&swapvar;
***/

%local i ap nchk chk swp ;

%let ap=0;

%if %sysfunc(exist(__final)) %then %do;
proc datasets nolist;
   delete __final;
quit;
%end;

proc sort data=&data out=__frame;
   by &id;
run;

%if &debug=1 %then %do;
proc print data=__frame;
   title3 "debug : __frame before swap";
run;
%end;

proc sort data=&sdata out=__swp;
   by &id;
run;

%repeat:

%let niter=%eval(&niter+1);

%put *;
%put *** Round &niter ;
%put *;
%put;

/***
data swp;
   set swp;
   n=1;
run;
***/

/***
proc summary nway data=__swp;
   var __one;
   output out=__nnum(drop=_type_ _freq_) sum=__swpn;
run;
***/

proc summary nway data=__swp;
   output out=__nnum(drop=_type_ rename=(_freq_=__swpn));
run;

*;
* define the file of swapping donors (i.e., those cases who are not;
* selected to be swapped.;
*;

data __frame;
   merge __frame(in=in1) __swp(in=in2);
   by &id;
   if not in2 ;
run;

proc summary nway data=__frame;
   output out=__frmn(drop=_type_ rename=(_freq_=__frmn));
run;

*;
* Check to make sure that there are enough donors to do the swapping;
* Otherwise, print off an error message.;
*;

%if &debug=1 %then %do;
proc print data=__frame;
   title3 "debug : __frame after subset to not selected";
run;
%end;

data _null_;
   merge __frmn __nnum;
   nchk='0';
   if __swpn ge __frmn then do;
      nchk='1';
      **put "&prgname ERROR: NOT ENOUGH CASES TO DO THE SWAP";
      call symput('err1',"&prgname Error: NOT ENOUGH CASES TO DO THE SWAP.");
      call symput('err2',"&prgname Error: The swapping rate (RATE) must be reduced.");
      call symput('nerr',"2");
   end;
   call symput ('nchk',nchk);
run;

%if &nchk=1 %then %do;
   %ds_prnerror;
   %goto sstop;
%end;

*;
* determine the number of donors in each cell;
*;

proc summary nway data=__frame;
   var __one;
   class &celln;
   output out=__n(drop=_type_ _freq_) sum=__numincl;
run;

*;
* Define a cell id to be used in proc transpose;
*;

data __n;
   set __n;
   __cellid='__c' || left(put(&celln,8.));
run;

%if &debug=1 %then %do;
proc print data=__n;
   title3 "debug : n before transpose";
run;
%end;

proc transpose data=__n out=__transn;
   var __numincl;
   id __cellid;
run;

%if &debug=1 %then %do;
proc print data=__transn;
   title3 "debug : transn after __transpose";
run;
%end;

proc datasets nolist;
   delete __n;
quit;

*;
* handle boundary and zone ;
*;

*** zone does not vary within a cell;

%if %length(&zone) > 0 %then %do;

proc summary nway data=&data;
   var __one;
   class &celln;
   id &zone;
   output out=__tmp1(drop=_type_ _freq_) sum=__numincl;
run;

*;
* Define a cell id to be used in proc transpose;
*;

data __tmp1;
   set __tmp1;
   __zoneid="__zone"||left(put(&celln,8.));
run;

%if &debug=1 %then %do;
proc print data=__tmp1;
title3 "debug : __tmp1 after assigning __zoneid";
run;
%end;

proc transpose data=__tmp1 out=__transn2;
   var __zone;
   id __zoneid;
run;

data __transn;
   merge __transn __transn2;
run;

proc datasets nolist;
   delete __transn2;
quit;
%end;

%if &debug=1 %then %do;
proc print data=__transn;
   title3 "debug : transn after transpose zone";
run;
%end;

*;
* determine the minimum and maximum values of &celln on the frame;
*;

proc summary data=__frame;
   var &celln;
   output out=__extremes(drop=_type_ _freq_) min=__minc max=__maxc;
run;

*;
* determine the minimum and maximum values of &celln on the swap file;
*;

proc summary nway data=__swp;
   var &celln;
   output out=__extreme(drop=_type_ _freq_) min=__min max=__max;
run;

data __transn;
   merge __transn __extremes __extreme;
   __one=1;
run;

***wch added for testing ;
*data __transn;
*  set __transn(drop=c4 c5);
*run;

%if &debug=1 %then %do;
proc print data=__swp;
   title3 "debug : swp before the big merge";
run;

proc print data=__transn;
   title3 "debug : transn before the big merge";
run;
%end;

*;
* Determine the neighboring cells (celln) for each unit requiring;
* swapping;
*;

data __cells(keep=&celln __ccell &id &biasvar &wgt
             rename=(&biasvar=__s&biasvar &id=__s&id &wgt=__s&wgt))
     __error(keep=&id &celln &cell __ccell &biasvar &wgt);
   if eof and nchk=1 then call symput('nchk',left(put(nchk,8.)));
   merge __swp __transn end=eof;
   by __one;
   array nx{&lval} __c1-__c&lval;
   array __z{&lval} __zone1-__zone&lval;
   retain nchk 0;
   __amin=min(__minc,__min);
   __amax=max(__maxc,__max);

   **** look left ****;
   do __j=&celln-1 to 1 by -1;
      if nx{__j} gt 0 then do;
            ***put "look left 1  : " &celln= __j= __lcell=  __z{&celln}=  __z{__j}=;
         if __z{&celln} = __z{__j} then do;
            __lcell=__j;
            ***put "look left 2  : " &celln= __j= __lcell=  __z{&celln}=  __z{__j}=;
            __j=-1;
         end;
      end;
   end;

   **** look right ****;
   do __j = &celln+1 to __amax;
      if nx{__j} gt 0 then do;
            ***put "look right 1 : " &celln= __j= __rcell= __z{&celln}= __z{__j}=;
         if __z{&celln} = __z{__j} then do;
            __rcell=__j;
            ***put "look right 2 : " &celln= __j= __rcell=  __z{&celln}=  __z{__j}=;
            __j = __amax+1;
         end;
      end;
   end;

   **** check if at least one found ****;
   if __rcell=. and __lcell=. then do;
      nchk=1;
      output __error;
   end;
   else do;
      if __lcell ne . then do;
         __ccell = __lcell;
         output __cells;
      end;
      if __rcell ne . then do;
         __ccell = __rcell;
         output __cells;
      end;
   end;

run;

/****
data __cells __error;
   if eof and nchk=1 then call symput('nchk',left(put(nchk,8.)));
   merge __swp __transn end=eof;
   by __one;
   array nx{&lval} __c1-__c&lval;
   retain nchk 0;
   __amin=min(__minc,__min);
   __amax=max(__maxc,__max);
   if &celln=__amin then do;
      do __j=__amin+1 to __maxc;
         if nx{__maxc-__j+__amin+1} gt 0 then __ccell=__maxc-__j+__amin+1;
         __jam = (__maxc-__j+__amin+1);
         put "lowest cell : " &celln= __maxc= __j= __amin= "(maxc-j+amin+1)=" __jam __ccell=;
      end;
      if __ccell ne . then output __cells;
      else do; nchk=1; output __error; end;
   end;
   else if &celln=__amax then do;
      do __j= __minc to __amax-1;
         if nx{__j} gt 0 then __ccell=__j;
            put "highest cell : " &celln= __j= __ccell=;
      end;
      if __ccell ne . then output __cells;
      else do; nchk=1; output __error; end;
   end;
   else do;
      do __j=__minc to &celln-1;
         if nx{__j} gt 0 then __ccell=__j;
         put "middle cell 1 : " &celln= __minc= __j= __ccell=;
      end;
      if __ccell ne . then output __cells;
      __lccell=__ccell;
      do __j=&celln to __maxc-1;
         if nx{__maxc-__j+&celln} gt 0 then __ccell=__maxc-__j+&celln;
         __jam = __maxc-__j+&celln;
         put "middle cell 2 : " &celln= __maxc= __j= "maxc-j+&cell=" __jam __ccell=;
      end;
      if __ccell ne __lccell then output __cells;
      if __ccell=. and __lccell=. then do; nchk=1; output __error; end;
   end;
   rename &biasvar=__s&biasvar &id=__s&id &wgt=__s&wgt;
   keep &celln __ccell &id &biasvar &wgt;
run;
****/

%if &nchk=1 %then %do;
   %let err1="no swapping partner";
   %put ;
   %put ;
   %put **************************************************************************;
   %put &prgname Error: ;
   %put &prgname Error: At least one selected case have no swapping partner.;
   %put &prgname Error: Refer to the .lst file for a listing of problematic cases.;
   %put &prgname Error: Run a cross-tabulation on the BOUNDARY*SWAPVARS;
   %put &prgname Error: variables to determine how to collapse cells so that;
   %put &prgname Error: swapping partners can be found.;
   %put &prgname Error: Program has aborted.;
   %put &prgname Error: ;
   %put **************************************************************************;
   %put ;
   %put ;

   proc sort data=__error;
      by &celln;
   run;
   proc print data=__error;
   %if %index(%quote(%str( )%upcase(&cell)%str( )),%quote(%str( )%upcase(&b_var)%str( )))=0 %then
      var &id &celln &cell &b_var &wgt __ccell;
   %else
      var &id &celln &cell &wgt __ccell;
   ;
      title3 "CASES HAVE NO SWAP PARTNER";
      footnote1 "You may want to loosen up the hard boundary definition";
      footnote2 "so there are more potential swap partners";
   run;
   footnote1;

   %If %length(&boundary) > 0 %then %do;
   proc sort data=&holder;
      by &celln;
   run;
   data __tmp1;
      merge &holder(keep=&id &celln &cell &biasvar &wgt &zone)
            __error(keep=&celln in=in2);
      by &celln;
      if in2;
   run;
   proc freq data=__tmp1;
      tables &zone/out=__tmp1 noprint missing list;
   run;
   proc sort data=&holder;
      by &zone;
   run;
   data __tmp1;
      merge &holder(keep=&id &celln &cell &biasvar &wgt &zone)
            __tmp1(keep=&zone in=in2);
      by &zone;
      if in2;
   run;
   proc print data=__tmp1;
   %if %index(%quote(%str( )%upcase(&cell)%str( )),%quote(%str( )%upcase(&b_var)%str( )))=0 %then
      var &id &celln &cell &b_var &wgt &zone;
   %else
      var &id &celln &cell &wgt &zone;
   ;

      title3 "CASES IN THE ABOVE HARD BOUNDARY(S)";
   run;
   proc print data=&holder;
   %if %index(%quote(%str( )%upcase(&cell)%str( )),%quote(%str( )%upcase(&b_var)%str( )))=0 %then
      var &id &celln &cell &b_var &wgt &zone;
   %else
      var &id &celln &cell &wgt &zone;
   ;
      title3 "ALL CASES";
   run;
   %end;

   %goto sstop;
%end;

%if &debug=1 %then %do;
proc print data=__cells;
   title3 "debug : __cells : after merge swp transn";
run;

proc print data=__error;
   title3 "debug : __error : after merge swp trans";
run;
%end;

proc sort data=__cells;
   by __ccell;
run;

*;
* count the number of times a neighboring swap cell is used;
*;

data __cells(drop=__cnt) __repeat(keep=__ccell __cnt);
   set __cells;
   by __ccell;
   retain __cnt;
   if first.__ccell then __cnt=0;
   __cnt=__cnt+1;
   __ext=__cnt;
   output __cells;
   if last.__ccell then output __repeat;
run;

%if &debug=1 %then %do;
proc print data=__cells;
   title3 "debug : __cells after define __repeat";
run;
proc print data=__repeat;
   title3 "debug : __repeat after define __repeat";
run;
%end;

proc sort data=__frame;
   by &celln;
run;

%if &debug=1 %then %do;
proc print data=__repeat;
   title3 "debug : __repeat before merge __frame __repeat";
run;
proc print data=__frame;
   title3 "debug : __frame before merge __frame __repeat";
run;
%end;

*;
* on the frame repeat the data within ccell the number of times ccell;
* are used;
*;

data __input;
   merge __frame __repeat(rename= __ccell=&celln in=in2);
   by &celln;
   if in2;
   do __ext=1 to __cnt;
      output;
   end;
run;

proc sort data=__input;
   by &celln __ext;
run;

%if &debug=1 %then %do;
proc print data=__input;
   title3 "debug : __input after merge __frame __repeat";
run;
proc print data=__input;
   title3 "debug : __input before merge __cells __input";
run;
proc print data=__cells;
   title3 "debug : __cells before merge __cells __input";
run;
%end;

*;
* merge the swap file with the donor file and compute error which is;
* the absolute difference in the sampling weights between the each swap;
* unit and each donor unit with the swap units neighboring cells.;
*;

data __cand;
   merge __cells(in=in1) __input(rename= &celln=__ccell);
   by __ccell __ext;
   if in1;
   __error=abs(&wgt-__s&wgt);
   __ran=ranuni(&actualseed);
run;

*;
* For each swapping unit find the cases with the smallest error with;
* each of the respective neighboring cells. Ties and handled by a ;
* random selection.;
*;
* Also compute the weighted swapping bias for the variable specified;
* in &biasvar.;
*;

proc sort data=__cand;
   by __s&id __ccell __error __ran;
run;

%if &debug=1 %then %do;
proc print data=__cand;
   title3 "debug : __cand after merge __cells __input";
run;
%end;

data __cand;
   set __cand(drop=__ran);
   by __s&id __ccell;
   if first.__ccell;
   __bias=abs((__s&wgt*&biasvar+&wgt*__s&biasvar)-(__s&wgt*__s&biasvar+&wgt*&biasvar));
   __ran=ranuni(&actualseed);
run;

%if &debug=1 %then %do;
proc print data=__cand;
   title3 "debug : __cand after define bias";
run;
%end;

*;
* For each swapping unit find the donor with the smallest swapping bias;
* Ties are handled through a random selection process.;
*;

proc sort data=__cand;
   by __s&id __bias __ran;
run;

%if &debug=1 %then %do;
proc print data=__frame;
   title3 "debug : __frame after define bias";
run;
proc print data=__input;
   title3 "debug : __input after define bias";
run;
proc print data=__cand;
   title3 "debug : __cand after define bias";
run;
%end;

data &swaps(keep=__s&id &id)
     __swpchk(keep=__s&id &id __bias __error __ran);
   set __cand(drop=__ran);
   by __s&id ;
   if first.__s&id;
   __ran=ranuni(&actualseed);
run;

%if &debug=1 %then %do;
proc print data=&swaps;
   title3 "debug : &swaps after split &swaps __swpchk";
run;
proc print data=__swpchk;
   title3 "debug : __swpchk after split &swaps __swpchk";
run;
%end;

*;
* check to see whether any selected donor is used multiple times.;
*;

proc sort data=&swaps out=__tst;
   by &id;
run;

%if &debug=1 %then %do;
proc print data=__tst;
   title3 "debug : __tst after rename &swaps=__tst";
run;
%end;

/***
data _null_;
   chk=0;
   call symput ('chk',chk);
run;
***/

%let chk=0;

*;
* count the number of times a donor is used.;
*;

data __tst1;
   set __tst;
   by &id;
   retain __cnt;
   if first.&id then __cnt=0;
   __cnt=__cnt+1;
   if last.&id then do;
      if __cnt gt 1 then do;
         output;
         __chk='1';
         call symput ('chk',__chk);
      end;
   end;
   keep &id;
run;

%if &debug=1 %then %do;
proc print data=__tst1;
   title3 "debug : __tst1 after define chk";
run;
%end;

*;
* if any are used more then once then determine where the donor works;
* best and use it there. A donor works best with the swapping case with;
* the smallest absolute bias. Ties are determined through a random;
* process.;
*;

%if &chk=1 %then %do;

%let ap=1;

proc sort data=__swpchk;
   by &id __bias __ran;
run;

data __swpchk;
   set __swpchk;
   by &id;
   if first.&id;
   keep __s&id &id;
run;

*;
* For the swapping cases and respective donors that have been finalized;
* append to file final. The other swapping cases will have to go through;
* the swapping process another time.;
*;

%if &debug=1 %then %do;
proc print data=__swpchk;
   title3 "debug : __swpchk before append to __final";
run;
%end;

proc append data=__swpchk base=__final;
run;

*;
* Eliminate from the swapping and donor files swaps and donors that;
* have been finalized.;
*;

data __s&id(keep=__s&id)
     __id(keep=&id);
   set __swpchk;
run;

data __s&id;
   set __s&id;
   rename __s&id=&id;
run;

proc sort data=__s&id;
   by &id;
run;

data __swp;
   merge __swp __s&id(in=in2);
   by &id;
   if not in2;
run;

proc sort data=__frame;
   by &id;
run;

data __frame;
   merge __frame __id(in=in2);
   by &id;
   if not in2;
run;

*;
* If any swapping cases do not have an assigned donor then repeat the;
* the swapping process.;
*;

%goto repeat;

%end;

*;
* When all swaps are assigned donors do the swapping of the swapping;
* variables.;
*;

%if &ap=1 %then %do;

data &swaps;
   set __final &swaps;
run;

%end;

*;
* Get the swapping variables.;
*;

/***
data _null_;
   set __swapvar;
   call symput("swp",swp);
run;
***/

%**** define what variables will be swapped ****;
*****%let swp=&cell &swapvar;
%let swp=&swapvar &linkvars;

*;
* Do the swapping;
*;

data __swp;
   set &swaps;
   __pid=&id;
   __psid=__s&id;
   drop __pid __psid;
   output;
   __s&id=__pid;
   &id=__psid;
   output;
run;

proc sort data=__swp;
   by &id;
run;

proc sort data=&data;
   by &id;
run;

data __swapdata;
   merge __swp(in=in1) &data(keep=&id &swp);
   by &id;
   if in1;
run;

proc sort data=__swapdata;
   by __s&id;
run;

%if &debug=1 %then %do;
proc print data=__swp;
title3 "__swp before final swap";
run;
proc print data=&data;
title3 "&data before final swap";
run;
proc print data=__swapdata;
title3 "__swapdata before final swap";
run;
%end;

%local id1 id2;
data &data;
   merge &data(in=in1 rename=(&id=__s&id &swp_RENAME)) __swapdata(in=in2);
   by __s&id;
   if &swp_IF then do;
      ***put "swapvar did not change " b= __o_b= id= __sid=;
      call symput('noswap',left("1"));
      call symput('id1',left(put(&id,8.)));
      call symput('id2',left(put(__s&id,8.)));
   end;

   /*** swap linkvars only if the corresponding swapvar changed ***/
   /**%if &n_linkvars ne %then %do;**/
     %do i=1 %to &n_linksets;
       if &&swapvar&i = __o_&&swapvar&i then do;
          %do j=1 %to &&n_link&i;
              &&linkv&i&j = __o_&&linkv&i&j;
          %end;
       end;
     %end;
   /**%end;**/

   if in1 and not in2 then do;
     %do i=1 %to &n_swapvars;
      &&swapvar&i=__o_&&swapvar&i;
     %end;
     %do i=1 %to &n_linkvars;
      &&linkvar&i=__o_&&linkvar&i;
     %end;
   end;

   drop &id;
   drop &swp_DROP;
run;

%if &debug=1 %then %do;
proc print data=&data;
title3 "&data after final swap";
run;
%end;

%if &noswap=1 %then %do;
    %let err1=&prgname Error: Failed to change the value of SWAPVARS="&swapvar" while swapping &id=%trim(&id1) and &id=%trim(&id2.).;
    %let nerr=1;
    %ds_prnerror;
%end;

data &data;
   set &data;
   rename __s&id=&id;
run;

%sstop:;

%mend Swap;

%macro summary;

   /*%ds_info;*/

   title "DATASWAP SUMMARY REPORT";

   /* produce summary report */

   /** Data Utility Measure for Tables - Hellinger's Distance **/

   title2 "Data Utility Measure for Tables";

   data __SummaryBase;
      length myO $1 myName $43 myTag $32
     %do i=1 %to &nRun;
      Run_&i
     %end;
     $9  myNumCell $7;
     call missing(of _all_);
     myName="Utility Measures for Tables";
     output;
     call missing(of _all_);
     output;
   run;

   proc sql noprint;
      create table __HD as
      select "1" as myO, __HD1.myName length=43, __HD1.myTag, __HD1.myNumCell
     %do i=1 %to &nRun;
      , __HD&i..myHD_CHAR as Run_&i
     %end;
      from __HD1
     %do i=2 %to &nRun;
      , __HD&i
     %end;
      where
           (__HD1.myName=__HD2.myName and __HD1.myTag=__HD2.myTag)
     %do i=3 %to &nRun;
       and (__HD1.myName=__HD&i..myName and __HD1.myTag=__HD&i..myTag)
     %end;
      ;
   quit;

   data __HD;
      set __HD end=eof;
      output;
      if eof then do;
         call missing(of _all_);
         do __i=1 to 2;
         output;
         end;
        %if %sysfunc(exist(__ASED2_1)) %then %do;
         myName="Utility Measures for Pairwise Associations";
         output;
         call missing(of _all_);
         output;
        %end;
        %else %if %sysfunc(exist(__ASED3_1)) %then %do;
         myName="Utility Measures for Multivariate Assoc.";
         output;
         call missing(of _all_);
         output;
        %end;
      end;
      drop __i;
   run;

   proc append base=__SummaryBase data=__HD force;
   run;

   %if &debug=1 %then %do;
   %do i=1 %to &nRun;
   proc print data=__HD&i;
      title3 "deubg : pre sorted __HD&i";
   run;
   %end;
   proc print data=__HD;
      title3 "debug : presorted __HD";
   run;
   proc contents data=__HD; run;
   title3;
   %end;

   /*
   proc print data=__HD split='#';
      var myName myTag Run_:;
      label myName="Application"
            myTag="For#Variable(s)"
           %do i=1 %to &nRun;
            Run_&i="Run &i"
           %end; ;
   run;
   */

   /** Data Utility Measure for Pairwise Associations - Pearson's and Cramer's Correlaton **/

   %if %sysfunc(exist(__ASED2_1)) %then %do;
   proc sql noprint;
      create table __ASED2(rename=(myN=myName)) as
      select "2" as myO,put(" ",$32.) as myTag, put(__ASED2_1.myName,$43.) as myN, put(" ",$7.) as myNumCell
     %do i=1 %to &nRun;
      , left(put(__ASED2_&i..myASEDvalue,9.6)) as Run_&i
     %end;
      from __ASED2_1
     %do i=2 %to &nRun;
      , __ASED2_&i
     %end;
      where
           (__ASED2_1.myName=__ASED2_2.myName)
     %do i=3 %to &nRun;
       and (__ASED2_1.myName=__ASED2_&i..myName)
     %end;
      ;
   quit;

   data __ASED2;
      set __ASED2 end=eof;
      output;
      if eof then do;
         call missing(of _all_);
         do __i=1 to 2;
         output;
         end;
         %if %sysfunc(exist(__ASED3_1)) %then %do;
         myName="Utility Measures for Multivariate Assoc.";
         output;
         call missing(of _all_);
         output;
         %end;
      end;
      drop __i;
   run;

   proc append base=__SummaryBase data=__ASED2 force;
   run;

   %if &debug=1 %then %do;
   %do i=1 %to &nRun;
   proc print data=__ASED2_&i;
      title3 "debug : pre sorted __ASED2_&i";
   run;
   %end;
   proc print data=__ASED2;
      title3 "debug : pre sorted __ASED2";
   run;
   proc contents data=__ASED2; run;
   title3;
   %end;
   /*
   proc print data=__ASED2 split='#';
      title2 "Data Utility Measure for Pairwise Associations";
      var myName Run_:;
      label myName="Application"
           %do i=1 %to &nRun;
            Run_&i="Run &i"
           %end; ;
   run;
   */
   %let dropdsn=&dropdsn __ASED2 __ASED2_1-__ASED2_&nRun;
   %end;

   /** Data Utility Measure for Regression Coefficients - Default and User-defined models **/

   %if %sysfunc(exist(__ASED3_1)) %then %do;
   proc sql noprint;
      create table __ASED3(rename=(myN=myName)) as
      select "3" as myO, put(" ",$32.) as myTag, put(__ASED3_1.myName,$43.) as myN, put(" ",$7.) as myNumCell
     %do i=1 %to &nRun;
      , left(put(__ASED3_&i..myASEDvalue,9.6)) as Run_&i
     %end;
      from __ASED3_1
     %do i=2 %to &nRun;
      , __ASED3_&i
     %end;
      where
           (__ASED3_1.myName=__ASED3_2.myName)
     %do i=3 %to &nRun;
       and (__ASED3_1.myName=__ASED3_&i..myName)
     %end;
      ;
   quit;
/*
   data __ASED3;
      set __ASED3 end=eof;
      if _n_=1 then do;
         myO="";
         myTag="";
         myName="";
        %do i=1 %to &nRun;
         Run_&i="";
        %end;
         output;
         myO="";
         myTag="";
         myName="Global Data Utility Measures for Multivariate Associations";
        %do i=1 %to &nRun;
         Run_&i="";
        %end;
         output;
      end;
      output;
   run;
*/
   proc append base=__SummaryBase data=__ASED3;
   run;

   %if &debug=1 %then %do;
   %do i=1 %to &nRun;
   proc print data=__ASED3_&i;
      title3 "debug : pre sorted __ASED3_&i";
   run;
   %end;
   proc print data=__ASED3;
      title3 "debug : pre sorted __ASED3";
   run;
   title3;
   %end;
   /*
   proc print data=__ASED3 split='#';
      title2 "Data Utility Measure for Regression Coefficients - Default and User-defined models";
      var myName Run_:;
      label myName="Application"
           %do i=1 %to &nRun;
            Run_&i="Run &i"
           %end; ;
   run;
   */
   %let dropdsn=&dropdsn __ASED3 __ASED3_1-__ASED3_&nRun;
   %end;

   %local est_ls cap ls;
   %let ls = %SYSFUNC(GETOPTION(LINESIZE));
   data _null_;
      call symput('est_ls',left(put((&nRun-4)*10+100,3.0)));
      call symput('cap',left(put(ceil((&ls-100)/10+4),3.0)));
   run;

   %if &est_ls <= &ls %then %do;
      proc print data=__SummaryBase split='#' noobs;
         var myName myTag Run_: myNumCell;
         label myName="Application"
               myTag="For#Variable(s)"
               myNumCell="Cell Count/#Small Cell"
              %do i=1 %to &nRun;
               Run_&i="Run &i#Seed=&&seed&i"
              %end; ;
      run;
   %end;
   %else %do;
      proc print data=__SummaryBase split='#' noobs;
         var myName myTag Run_1-Run_&cap myNumCell;
         label myName="Application"
               myTag="For#Variable(s)"
               myNumCell="Cell Count/#Small Cell"
              %do i=1 %to &cap;
               Run_&i="Run &i#Seed=&&seed&i"
              %end; ;
      run;
      %if &cap<&nRun %then %do;
      proc print data=__SummaryBase split='#' noobs;
         var myName myTag Run_5-Run_&nRun myNumCell;
         label myName="Application"
               myTag="For#Variable(s)"
               myNumCell="Cell Count/#Small Cell"
              %do i=5 %to &nRun;
               Run_&i="Run &i#Seed=&&seed&i"
              %end; ;
      run;
      %end;
   %end;

   %local nRow nHD nPWA1 nPWA2 nREG nMod;

   proc sql noprint;
      select count(*) into :nRow
      from __SummaryBase(where=(not missing(myO)));
   quit;
   %let nRow=&nRow;

   proc sql noprint;
      select count(*) into :nHD
      from __SummaryBase(where=(not missing(myO)))
      where myName like "Hellinger%"
      ;
   quit;

   %let nPWA1=%eval(&nHD+1);
   %let nPWA2=%eval(&nPWA1+2);
   %let nMod=%eval(&nRow-&nPWA2);
   %let nREG=%eval(&nMod-1);


   data __HD_transposed;
      array __runs(&nRun) $10 Run_1-Run_&nRun;
      array __instats(&nRun,&nRow)
       %do i=1 %to &nRun;
       __instats&i._1-__instats&i._&nRow
       %end;
       ;
      retain
      %do i=1 %to &nRun;
      __instats&i._1-__instats&i._&nRow
      %end;
      ;
      array __outstats(&nRow) __outstats1-__outstats&nRow;

      if eof then do;
         do __irun=1 to &nrun;
            RunNum=__irun;
            do __irow=1 to &nrow;
               __outstats(__irow) = __instats(__irun,__irow);
            end;
            output;
         end;
      end;
      set __SummaryBase(where=(not missing(myO))) end=eof;
      __irow+1;
      do __irun=1 to &nRun;
         __instats(__irun,__irow)=input(substr(__runs(__irun),1,9),8.0);
      end;

      keep RunNum __outstats1-__outstats&nRow;

   run;


   %local legend3 outstats3;
   %if &nMod > 0 %then %do;
      %do i=1 %to &nMod;
         %local modlabel&i;
      %end;
      proc sql noprint;
         select myName into :modlabel1 - :modlabel&nMod
         from __SummaryBase
         where myO="3";
      quit;
      %let modlabel&nMod=Regression utility measure across all models;

      %if &nMod <=4 %then %do;
         %do i=1 %to &nMod;
            %let legend3=&legend3 "&&modlabel&i";
         %end;

         %let outstats3=__outstats%eval(&nPWA2+1)-__outstats&nRow;
      %end;
      %else %do;

      %end;
   %end;

   options nonumber;
   goptions ftext='Helvetica' htext=2 gunit=pct  ;
   symbol1  v=dot i=join h=3 l=1 ci=blue cv=blue;
   symbol2 f=marker v='U' i=join h=2 l=3 ci=green cv=green;
   symbol3  f=marker v='C' i=join h=2 l=5 ci=red cv=red;
   symbol4  f=marker v='R' i=join h=2 l=5 ci=cyan cv=cyan;
   axis1 label=(angle=90 "Data Untility Measure" h=2.5);
   axis2 label=("Run Number" h=2.5);
   legend1 value=("Hellinger's Distance, all cells-across all swapping variables" "Hellinger's Distance, excluding small cells-across all swapping variables") label=none  position=(bottom center outside )  across=1 shape=symbol(6,1.25);
   legend2 value=("Pearson's Product Correlation" "Pearson's Contingency Coefficient" "Cramer's V") label=none  position=(bottom center outside ) across=1 shape=symbol(6,1.25);
   %if &nMod > 0 %then %do;
   %if &nMod <= 4 %then %do;
   legend3 value=(&legend3) label=none  position=(bottom center outside )  across=1 shape=symbol(6,1.25);
   %end;
   %else %do;
    %do i=1 %to &nMod;
    legend%eval(&i+2) value=("&&modlabel&i") label=none  position=(bottom center outside )  across=1 shape=symbol(6,1.25);
    %end;
   %end;
   %end;
   title3 h=4 f='Helvetica/it' "DataSwap";
   title4 h=4 f='Helvetica/bo' "Summary Utility Measures";
   footnote j=right "&program_path.&program_prefix._SummaryGraph.&graphtype";

   ods listing close;
   ods &graphtype file="&program_path.&program_prefix._SummaryGraph.&graphtype" ;

   proc gplot data=__HD_transposed;
      plot (__outstats1 __outstats2)*runnum / overlay legend=legend1 vaxis=axis1 haxis=axis2 caxis = BLACK ctext = BLACK  cframe = CXF7E1C2;
   run;

   %if %sysfunc(exist(__ASED2_1)) %then %do;
   proc gplot data=__HD_transposed;
      plot (__outstats&nPWA1-__outstats&nPWA2)*runnum / overlay legend=legend2 vaxis=axis1 haxis=axis2 caxis = BLACK ctext = BLACK  cframe = CXF7E1C2;
   run;
   %end;

   %if &nMod > 0 %then %do;
   %if &nMod <= 4 %then %do; /*plot regression only if there is at least one model*/
   proc gplot data=__HD_transposed;
      plot (&outstats3)*runnum / overlay legend=legend3 vaxis=axis1 haxis=axis2 caxis = BLACK ctext = BLACK  cframe = CXF7E1C2;
   run;
   %end;
   %else %do;
     %do i=1 %to &nMod;
      proc gplot data=__HD_transposed;
         plot (__outstats%eval(&nPWA2+&i))*runnum / overlay legend=legend%eval(&i+2) vaxis=axis1 haxis=axis2 caxis = BLACK ctext = BLACK  cframe = CXF7E1C2;
      run;
      quit;
     %end;
   %end;
   %end;

   ods &graphtype close;
   ods listing;
   quit;
   options number;

   proc datasets nolist;
      delete __HD __HD1-__HD&nRun &dropdsn __HD_transposed __SummaryBase;
   quit;


%mend summary;